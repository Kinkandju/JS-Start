# Шпаргалка по JS

## Оглавление
1. [Переменные](#переменные)
2. [Константы](#константы)
3. [Выражения в определениях](#выражения)
4. [Стили именования](#именования)
  + [Магические числа](#магия)
5. [Интерполяция](#интерполяция)
6. [Извлечение символов из строки](#извлечение)
7. [Типы данных](#типы)
  + [1. Число](#число)
  + [2. BigInt](#BigInt)
  + [3. Строка](#строка)
  + [4. Булевый (логический) тип](#булево)
  + [5. Значение «null»](#null)
  + [6. Значение «undefined»](#undefined)
  + [7. Символ](#символ)
  + [8. Объект (только этот тип данных не является примитивным)](#объект)
8. [Преобразование типов](#преобразование)
9. [Неизменяемость и примитивные типы](#неизменяемость)
10. [Слабая типизация](#типизация)
11. [Функции и их вызов](#функции)
  + [Математические функции](#Math)
  + [Параметры по умолчанию](#параметры)
  + [Вызов функции - выражения](#вызов)
  + [Функции с переменным числом параметров](#переменные-параметры)
  + [Детерминированность](#детерминированность)
  + [Побочные эффекты](#побочные)
12. [Стандартная библиотека](#библиотека)
13. [Свойства и методы](#свойства)
  + [Методы](#методы)
  + [Неизменяемость](#неизменность)
  + [Свойства и методы как выражения](#как-выражения)
  + [Цепочка вызовов](#цепочка)
14. [Определение функций](#определение)
  + [Возврат значений](#возврат)
  + [Параметры функций](#параметры-функций)
  + [Необязательные параметры функций](#необязательные-параметры)
  + [Упрощенный синтаксис функций](#упрощенный-синтаксис)
15. [Логика](#логика)
  + [Логический тип](#логический-тип)
  + [Предикаты](#предикаты)
  + [Комбинирование логических операций](#комбинирование)
  + [Логические операторы](#операторы)
  + [Результат логических операций](#результат-операций)
  + [Ошибка выбора](#ошибка-выбора)
16. [Условные конструкции](#условные-конструкции)
  + [if](#if)
  + [else](#else)
  + [else if](#else-if)
  + [Тернарный оператор](#тернарный)
  + [Конструкция Switch](#switch)
17. [Циклы](#циклы)
  + [Цикл while](#while)
  + [Синтаксический сахар](#сахар)
  + [Агрегация данных](#агрегация)
  + [Формирование строк](#формирование-строк)
  + [Условия внутри тела цикла](#условия-внутри)
  + [Инкремент и декремент](#инкремент-декремент)
  + [Цикл for](#for")
18. [Модули](#модули)


## <a name="переменные">Переменные</a>

Для удобства анализа программы, переменные принято создавать как можно ближе к тому месту, где они используются. Переменная должна быть определена до того, как будет использована.

```
let greeting = 'Hello!';
```

* __let__ - ключевое слово для создания переменной. Ключевое слово **let** ставится только при создании переменной, но при изменении оно уже не используется.
* __greeting__ - имя переменной;
* __=__ - оператор присваивания;
* __'Hello!'__ - значение;

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, а также знаки **_** и **$**. При этом цифру нельзя ставить в начале.

Регистр в JavaScript имеет важное значение.

## <a name="константы">Константы</a>

Имена констант с заранее известным значением принято записывать в верхнем регистре и отделять нижним подчеркиванием.

```
const BOX_WIDTH = 55;
```

Имена констант со значением присвоенным в процессе выполения программы.

```
const euros = 1000;
```

Если значение у переменной не меняется, то мы имеем дело с константой. Менять содержимое константы нельзя. Переменные жизненно необходимы только в одном случае (во всех остальных гарантированно можно обойтись без них) – при работе с циклами.

Предпочтительно использовать только константы и добавлять переменные только тогда, когда без них нельзя обойтись.

## <a name="выражения">Выражения в определениях</a>

```
let dollarsCount = 50 * 1.25; - справа от знака равно находится выражение.
```

Любая строка — выражение. Конкатенация строк — тоже выражение. Когда интерпретатор видит выражение, он обрабатывает его и генерирует результат — значение выражения.

__Всё это выражения:__
    Выражения    | Результат
-----------------|:-------: 
62.5             |   62.5 
50 * 1.25        |   62.5
120 / 10 * 2     |   24
'hello'          |   hello
'Good' + 'will'  |   Goodwill

Любая переменная может быть частью любого выражения. В момент вычисления, вместо имени переменной подставляется ее значение.

## <a name="именования">Стили именования</a>

* _kebab-case_ — составные части переменной разделяются дефисом. Например: my-super-var.
* *snake_case* — для разделения используется подчеркивание. Например: my_super_var.
* _CamelCase_ — каждое слово в переменной пишется с заглавной буквы. Например: MySuperVar.
* _lowerCamelCase_ — каждое слово в переменной пишется с заглавной буквы, кроме первого.

В Javascript используется **CamelCase** и его вариация **lowerCamelCase**, при котором первая буква первого слова — строчная. Именно **lowerCamelCase** применяется для переменных.

### <a name="магия">Магические числа</a>

**Magic Numbers** (магические числа) - числа, происхождение которых невозможно понять без глубокого знания происходящего внутри данного участка кода.

## <a name="интерполяция">Интерполяция</a>

Интерполяция работает только со строками в бектиках. Это символ **`**.

```
const firstName = 'Joffrey';
const greeting = 'Hello';

console.log(`${greeting}, ${firstName}!`);
```

Почти во всех языках интерполяция предпочтительнее конкатенации для объединения строк. Строка при этом получается склеенная, и внутри нее хорошо просматриваются пробелы и другие символы. Во-первых, интерполяция позволяет не путать строки с числами (из-за знака **+**), а во-вторых, так гораздо проще (после некоторой практики) понимать строку целиком.

## <a name="извлечение">Извлечение символов из строки</a>

```
const firstName = 'Tirion';

console.log(firstName[0]);
```

Квадратные скобки с цифрой — это специальный синтаксис извлечения символа из строки. Цифра называется индексом — позицией символа внутри строки. Индексы начинаются с 0 почти во всех языках программирования — поэтому, чтобы получить первый символ, нужно указать индекс 0. Индекс последнего элемента равен длине строки минус единица.

Индексом может быть не только конкретное число, но и значение переменной. 

Обращение по несуществующему индексу вернет значение undefined.

## <a name="типы">Типы данных</a>

Значение в JavaScript всегда относится к данным определённого типа. Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число.

Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.

JavaScript позволяет узнать тип данных с помощью оператора **typeof**.

```
typeof 3;      // number
typeof 'Game'; // string
```

### <a name="число">1. Число</a>

Числовой тип данных **(number)** представляет как целочисленные значения, так и числа с плавающей точкой.

В математике существуют разные виды чисел, например, _натуральные_ – это целые числа от одного и больше, или _рациональные_ – это числа с точкой, например 0.5.

Для нас, как для разработчиков, важно понимать, что операции с плавающими числами неточны (эту точность можно регулировать), а значит при решении задач, связанных с подобными числами, необходимо прибегать к специальным трюкам, которые позволяют добиться необходимой точности.

Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: **Infinity**, **-Infinity** и **NaN**. Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.

* _Infinity_ представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
* _NaN_ означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции. Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (есть только одно исключение: NaN ** 0 равно 1).

### <a name="BigInt">2. BigInt</a>

Тип _BigInt_ был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:

```
const bigInt = 1234567890123456789012345678901234567890n; - символ "n" в конце означает, что это BigInt
```

### <a name="строка">3. Строка</a>

Строка **(string)** в JavaScript должна быть заключена в кавычки. В JavaScript существует три типа кавычек:
1. Двойные кавычки: "Привет".
2. Одинарные кавычки: 'Привет'.
3. Обратные кавычки: `Привет`.

Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.

Обратные же кавычки имеют расширенную функциональность. Они позволяют использовать интерполяцию **${…}**.
Выражение внутри **${…}** вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную, или выражение (1 + 2), или что-то более сложное.

### <a name="булево">4. Булевый (логический) тип</a>

Булевый тип **(boolean)** может принимать только два значения: _true_ (истина) и _false_ (ложь).

Такой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно», а false значит «нет, не правильно».

Булевые значения также могут быть результатом сравнений: 
``` 
4 > 1 - true 
```

### <a name="null">5. Значение «null»</a>

Специальное значение **null** не относится ни к одному из типов, описанных выше.

Оно формирует отдельный тип, который содержит только значение **null**. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

### <a name="undefined">6. Значение «undefined»</a>

Специальное значение **undefined** также стоит особняком. Оно означает, что «значение не было присвоено». 

Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет **undefined**.

### <a name="undefined">7. Символ</a>

Тип **symbol** (символ) используется для создания уникальных идентификаторов в объектах. 

### <a name="объект">8. Объект (только этот тип данных не является примитивным)</a>

Тип **object** (объект) – особенный.

Все остальные типы называются _«примитивными»_, потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

## <a name="преобразование">Преобразование типов</a>

В программировании регулярно встречаются задачи, когда один тип данных нужно преобразовать в другой — например, при работе с формами на сайтах. Данные формы всегда приходят в текстовом виде, даже если значение — число.

**parseInt()** — это функция, в которую передается значение, чтобы его преобразовать. Функция ведет себя подобно арифметическим операциям, но делает особые действия. Вот еще несколько примеров:

```
const value = '0';
```

Внутри скобок можно указывать переменную.

```
const number1 = parseInt(value);

console.log(number1); // => 0
```

Или конкретное значение.

```
const number2 = parseInt('10');

console.log(number2); // => 10
```

Если преобразуется число с плавающей точкой, то отбрасывается вся дробная часть.

```
const number5 = parseInt(3.5);

console.log(number5); // => 3
```

С помощью **parseFloat()** точно так же можно преобразовать строку в число с плавающей точкой:

```
const value3 = parseFloat('0.5');

console.log(value3); // 0.5
```

## <a name="неизменяемость">Неизменяемость и примитивные типы</a>

Что произойдет, если попытаться изменить символ в строке?

```
let firstName = 'Alexander';
```

Код выполнится без ошибок.

```
firstName[0] = 'B';

console.log(firstName); // => Alexander
```

Как это ни странно, но значение переменной firstName останется прежним, хотя код выполнится без ошибок. Так происходит из-за неизменяемости примитивных типов в JavaScript — язык не дает никакой физической возможности поменять строку. Неизменяемость примитивных типов важна по многим причинам, ключевая — производительность. Но что делать, если нам действительно нужно ее изменить? Для этого и существуют переменные.

Есть большая разница между изменением значения переменной и изменением самого значения. Примитивные типы в JavaScript поменять нельзя, а заменить значение переменной — без проблем.

## <a name="типизация">Слабая типизация</a>

JavaScript — это язык со **слабой типизацией**. Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию, когда это кажется разумным.

```
console.log(1 + '7'); // => 17
```

В языках со **строгой типизацией** сложить число со строкой не получится.

JavaScript был создан для интернета, а в интернете вся информация — это строки. Даже когда вы вводите на сайте номер телефона или год рождения, на сервер эта информация поступает не как числа, а как строки. Поэтому авторы языка решили, что автоматически преобразовывать типы — правильно и удобно.

## <a name="функции">Функции и их вызов</a>

Для выражения любой произвольной операции в программировании существует понятие функция. Функции бывают как встроенные, так и добавленные программистом.

**Функции** — одна из ключевых конструкций в программировании, без них невозможно сделать практически ничего.

Параметры (или _аргументы_) — это информация, которую функция получает при вызове. Именно на основе этой информации функция, как правило, вычисляет что-то и выдает результат.

Мы создали константу _result_ и указали интерпретатору записать в нее результат, возвращаемый функцией _length()_ при ее вызове. В этом смысле функции подобны операциям – они всегда возвращают результат своей работы.

```
const result = length('Hello!');
```

Запись _length('Hello!')_ означает, что вызывается функция с именем _length_, в которую был передан параметр _'Hello!'_. Функция _length()_ считает длину именно той строки, которая ей была передана.

Вызов функции всегда обозначается скобками **()**, идущими сразу за именем функции. В скобках может быть любое количество параметров, а иногда — вообще ни одного. Количество зависит от используемой функции.

```
const result = pow(2, 3); // 2 * 2 * 2
```

Вызов pow(2, 3) возвращает значение 2 в 3 степени.

По большому счету, операторы и функции — это одно и то же. Ключевая разница только в том, как они записываются. Если представить (гипотетически) сложение как функцию, то она будет выглядеть так:

* Обычное сложение: _3 + 5;_ // 8
* Сложение, представленное как функция: _+(3, 5);_

Функции вызываются и возвращают результат, который затем может быть использован в дальнейших вычислениях или, например, выведен на экран.

### <a name="Math">Математические функции</a>

В предыдущем задании мы использовали самописную функцию **pow()**, а теперь давайте рассмотрим ее версию, встроенную в сам язык.

```
Math.pow(2, 3); // 8
```

Что такое **Math**? Технически — это объект, доступный из любого места программы. Функции для математических операций вызываются через **Math.**.

Функция _Math.pow()_, возводящая число в какую-нибудь степень, принимает два параметра: **какое число возводить** и **в какую степень возводить**. Если вызывать _pow()_ без параметров, то вернется **NaN**. Функция честно пытается выполнить возведение в степень, но если значение не передано, то интерпретатор автоматически передает ей **undefined**.

Откуда мы знаем, сколько каких параметров нужно функции **Math.pow()** и какого типа будет «возврат»? Мы заглянули в **сигнатуру** этой функции. Сигнатура определяет входные параметры и их типы, а также выходной параметр и его тип.

### <a name="параметры">Параметры по умолчанию</a>

Рассмотрим функцию **round()**, которая округляет число с плавающей точкой:

```
const result = round(10.25, 0); // 10
```

Мы передали в нее два параметра: число, которое нужно округлить, и точность округления. **0** означает, что округление будет до ближайшего целого значения.

Чаще всего нужно округлять именно до целого числа (а не до десятых, например), поэтому создатели функции **round()** сделали второй параметр _необязательным_ и задали ему внутри функции значение по умолчанию **0**. Значит, можно не указывать второй параметр, а результат будет тем же:

```
const result = round(10.25); // 10
```

Если функция в JavaScript принимает необязательные параметры, то они всегда стоят после обязательных. Их количество может быть любым (это зависит от самой функции), но они всегда идут рядом и в конце списка аргументов.

### <a name="вызов">Вызов функции - выражения</a>

В программировании выражение – нечто, возвращающее результат, который можно использовать. Математические операции (сложение, вычитание), строковые операции (конкатенация) – все это выражения.

Особенность выражений в том, что они возвращают результат, который можно, например, присвоить константе или вывести на экран.

Но не все в программировании является выражением. Определение переменной – это инструкция, она не может быть частью выражения. То есть такой код выдаст ошибку:

```
10 + const sum = 1 + 5;
```

Выражения можно комбинировать, получая все более сложное поведение в самых неожиданных местах и самым неожиданным образом.

Функции возвращают результат, поэтому они считаются выражениями. Из этого автоматически следует много интересного. Например, мы можем использовать вызов функции прямо в математических операциях. Все это справедливо для любых функций, например, строковых.

### <a name="переменные-параметры">Функции с переменным числом параметров</a>

Интересная особенность некоторых функций — принимать переменное число параметров.

```
Math.max(1, 10, 3); // 10
```

Функция **Math.max()** находит максимальное значение среди переданных параметров.

```
Math.max([value1[, value2[, ...]]])
```

Такая запись говорит о том, что эта функция принимает на вход любое число параметров (и даже может быть вызвана без них). Необязательность передаваемых параметров описывается скобками **[ ]**, точно так же описываются и опциональные параметры, у которых есть значения по умолчанию. Возможность передачи любого числа параметров зашита в этой части **[, ...]**.

### <a name="детерминированность">Детерминированность</a>

Независимо от того, какой язык программирования используется, функции внутри него обладают некоторыми фундаментальными свойствами. Зная эти свойства, легче прогнозировать поведение функций, способы их тестирования и место их использования. К таким свойствам относится _детерминированность_.

Функция называется **детерминированной** тогда, когда для одних и тех же входных параметров она возвращает один и тот же результат.

Например, функция, считающая количество символов, детерминированная, в свою очередь функция, возвращающая случайное число, не является детерминированной, так как у одного и того же входа (даже если он пустой, то есть параметры не принимаются) мы получим всегда разный результат.

Детерминированность серьезно влияет на многие аспекты. Детерминированные функции удобны в работе, их легко оптимизировать, легко тестировать. Если есть возможность сделать функцию детерминированной, то лучше ее такой и сделать.

### <a name="побочные">Побочные эффекты</a>

Что возвращает функция _console.log()?_ Ответ: что бы она ни возвращала, это значение никак не используется.

**console.log()** выводит что-то на экран, но это не возврат значения, это просто какое-то действие, которое выполняет функция. Вывод на экран и возврат значения из функции — разные и независимые операции.

С точки зрения программы вывод на экран — это так называемый **побочный эффект**. Побочным эффектом называют действия, которые изменяют внешнее окружение (среду выполнения). К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран или печать на принтере и так далее.

Побочные эффекты — один из основных источников проблем и ошибок в программных системах. Код с побочными эффектами сложен в тестировании, ненадежен. При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы (записать в базу, вывести на экран, отправить по сети и так далее).

## <a name="библиотека">Стандартная библиотека</a>

JavaScript, как и любой другой язык, поставляется с набором полезных функций. Все вместе они составляют так называемую **стандартную библиотеку**. В нее обычно входят тысячи функций, которые невозможно выучить — этого и не нужно делать.

Любой разработчик в процессе своего профессионального взросления знакомится со все более интересными функциями, решающими его задачи более элегантно, и таким образом пополняет свой арсенал.

Вот некоторые советы, как узнавать о новых функциях:

* Всегда четко отслеживайте, с чем вы сейчас работаете (какой тип данных). Почти всегда вы найдете необходимую функцию в соответствующем разделе документации — например, для работы со строками нужно изучать строковые функции;
* Периодически открывайте раздел со стандартными функциями по изучаемой тематике и просто пробегайтесь по ним, изучая сигнатуры и способы использования;
* Чаще читайте чужой код, особенно код библиотек, которые вы используете. Он весь доступен на GitHub.

У JavaScript есть свои особенности по структуре стандартной библиотеки. Так как его код может исполняться в разных средах, таких как серверное окружение или браузер, то возможности стандартной библиотеки сильно зависят от варианта использования.

## <a name="свойства">Свойства и методы</a>

В JavaScript свойства встроены прямо в язык. Они указываются через точку сразу после переменной (или константы):

```
const name = 'Robb';
const len = name.length;
```

Свойства связаны с данными, у которых они берутся. Для стандартных типов все свойства описаны в документации, как например, у строк. При этом у чисел вообще нет свойств.

JavaScript позволяет обращаться к свойствам, которые не существуют (например, при опечатках). В таком случае их значением является undefined.

### <a name="методы">Методы</a>

В JavaScript у данных есть не только свойства, но и методы. **Методы** - это функции, которые находятся внутри свойств. Это означает, что метод можно вызвать как функцию, но при этом он работает как свойство и вызывается через точку.

```
const name = 'Robb';
const upperName = name.toUpperCase();
```

Встроенные методы всегда оперируют теми данными, с которыми они связаны. Методов у данных обычно значительно больше, чем свойств, например, для строк их несколько десятков.

Методы есть и у чисел, но технически всё несколько сложнее. Методы есть не у самих чисел, а у данных (объектов) типа **Number**. Числа, записанные в переменные или константы, автоматически преобразуются к данному типу во время обращения к ним, в это время происходит так называемый **boxing**.

### <a name="неизменность">Неизменяемость</a>

Логика справедлива для методов всех примитивных типов. Более того, попытка изменить значение свойства этих данных ни к чему не приведет:

```
const name = 'Tirion';
console.log(name.length); // => 6

name.length = 100;
console.log(name.length); // => 6
```

Вместо изменения значения можно заменить значение. Для этого понадобятся переменные:

```
let name = 'Tirion';
name = name.toUpperCase();

console.log(name); // => TIRION
```

### <a name="как-выражения">Свойства и методы как выражения</a>

Свойства и методы — такие же выражения, как переменные, константы или вызовы функции, а значит, их можно всячески комбинировать.

```
const name1 = 'Robb';
const name2 = 'Shaya';

console.log(Math.min(name1.length, name2.length)); // => 4
```

### <a name="цепочка">Цепочка вызовов</a>

Синтаксис нескольких подряд идущих операций можно записать как:

```
const name = 'Tirion';

console.log(name.length.toString());
```

Все, что произошло в этом коде — это объединение уже известных возможностей языка. Такое в программировании происходит довольно часто. Даже не зная синтаксиса, можно пробовать комбинировать различные подходы, и есть неплохая вероятность, что они заработают.

Самый простой способ понять, как работает этот код — разбить цепочку на отдельные операции:

```
const name = 'Tirion';
const len = name.length;

console.log(len.toString());
```

Эти примеры абсолютно эквивалентны. Мы можем выполнять операции последовательно с промежуточным созданием констант, а можем строить непрерывную цепочку из свойств и методов. **В цепочках вычисления всегда идут слева направо.**

## <a name="определение">Определение функций</a>

Определение собственных функций значительно упрощает написание и поддержку программ. Функции позволяют объединять сложные (составные) операции в одну.

// **Определение функции**

// Определение не вызывает и не выполняет функцию

// Мы лишь говорим, что теперь такая функция существует

```
 const showGreeting = () => {
  const text = 'Hello, Hexlet!';
  console.log(text);
};
``` 
// **Вызов функции**

```
 showGreeting(); // => Hello, Hexlet!
``` 
В отличие от обычных данных, функции _выполняют действия_, поэтому их имена практически всегда должны быть _глаголами_: «построить что-то», «нарисовать что-то», «открыть что-то».

Все, что описывается внутри фигурных скобок {}, называется **телом функции**. Внутри тела можно описывать любой код. Считайте, что это маленькая самостоятельная программа, набор произвольных инструкций. Тело выполняется ровно в тот момент, когда запускается функция. Причем каждый вызов функции запускает тело независимо от других вызовов. Кстати, тело может быть пустым.

Определение функции подозрительно похоже на создание константы. Действительно, в реальности, определение функции состоит из двух частей: собственно определения и присваивания константе:

* Определение: **() => { }**
* Присваивание **const nameOfFunction = ...**

### <a name="возврат">Возврат значений</a>

**return** – особая инструкция, которая берет выражение, записанное справа, и отдает его наружу, тому коду, который вызвал функцию. Как только JavaScript натыкается на return, выполнение функции на этом завершается.

Любой код после _return_ не выполняется:

```
const greetingWithCodeAfterReturn = () => {
  return 'Hello, Hexlet!';
  console.log('Я никогда не выполнюсь');
};
```
Возвращать можно не только конкретное значение. Так как _return_ работает с выражениями, то справа от него может появиться почти все что угодно. Здесь нужно руководствоваться принципами читаемости кода.

### <a name="параметры-функций">Параметры функций</a>

Функции могут не только возвращать значения, но и принимать их в виде параметров (их еще называют аргументами).

Представим, что перед нами стоит задача – реализовать функцию **getLastChar()**. Она возвращает последний символ в строке, переданной на вход как параметр.

Вот как будет выглядеть использование этой функции:

```
// Передача параметров напрямую без переменных
getLastChar('Hexlet'); // t

// Передача параметров через переменные
const name1 = 'Hexlet';
getLastChar(name1); // t

const name2 = 'Goo';
getLastChar(name2); // o
```

Из описания и примеров кода мы можем сделать следующие выводы:

* Нам нужно определить функцию **getLastChar()**
* Функция должна принимать на вход один параметр строкового типа
* Функция должна возвращать значение строкового типа

Имя параметра может быть любым. Главное, чтобы оно отражало смысл того значения, которое содержится внутри. Мы могли бы определить функцию и вот так:

```
const getLastChar = (str) => {
  return str[str.length - 1];
};
```

Точно таким же образом можно указывать два, три и более параметров. Каждый параметр отделяется от другого запятой:

```
// функция по нахождению среднего числа
const average = (a, b) => {
  return (a + b) / 2;
};

average(1, 5); // 3
average(1, 2); // 1.5
```

Тоже самое относится и к методам. Они могут требовать на вход любое количество параметров, которое им нужно для работы:

```
// первый параметр – что ищем
// второй параметр – на что меняем
'google'.replace('go', 'mo'); // moogle
```

Чтобы создать такие функции и методы, нужно в определении указать необходимое количество параметров через запятую, дав им понятные имена. Ниже пример определения функции _replace()_, которая заменяет в слове одну часть строки на другую:

```
const replace = (text, from, to) => {
  // здесь тело функции, но мы его опускаем, чтобы не отвлекаться
};

replace('google', 'go', 'mo'); // moogle
```

Когда параметров два и более, то практически для всех функций становится важен порядок передачи этих параметров. Если его поменять, то функция отработает по-другому.

### <a name="необязательные-параметры">Необязательные параметры функций</a>

В программировании большое количество функций и методов имеют параметры, которые редко меняются. В таких случаях этим параметрам задают значения по умолчанию, которые можно поменять по необходимости.

Значение по умолчанию выглядит как обычное присваивание в определении. Оно срабатывает только в том случае, если аргумент не передан. К этому нужно привыкнуть.

Значение по умолчанию может быть даже в том случае, когда параметр один:

```
const print = (text = 'nothing') => console.log(text);

print(); // nothing
print("World"); // World
```

Параметров со значениями по умолчанию может быть сколько угодно. У значений по умолчанию есть одна особенность — они должны идти в самом конце списка параметров. Значения, передаваемые функции при вызове, всегда записываются в параметры слева направо, в том порядке, в котором они переданы. Получается, что если значения по умолчанию идут слева в списке параметров, перед обычными параметрами, то при вызове функции с какими-либо аргументами на место значений по умолчанию встанут значения аргументов.

### <a name="упрощенный-синтаксис">Упрощенный синтаксис функций</a>

По сравнению с некоторыми (в первую очередь функциональными) языками, определение функции в JavaScript выглядит довольно громоздко:

```
const square = (x) => {
  return x ** 2;
};
```

Здесь используется много дополнительных символов и слово return. С версии es6 в языке появился альтернативный, сокращенный синтаксис, который, в некоторых ситуациях, значительно упрощает восприятие и сокращает количество кода.

```
const double = (x) => x ** 2;
```

Отличия от полного определения два: пропали фигурные скобки и инструкция return. Сокращенная запись функции делает возврат автоматически. Подразумевается, что внутри такой функции ровно одно выражение, которое вычисляется, и его результат сразу возвращается наружу.

Обратите внимание на **отсутствие** фигурных скобок. Разработчики, которые не привыкли использовать такой синтаксис, иногда пишут подобный код _const sum = (a, b) => { a + b };_, а потом долго не могут понять, почему он не работает. Ответ очень простой: если стоят фигурные скобки, то это не сокращенная форма, а значит, чтобы функция вернула значение, придется поставить return.

## <a name="логика">Логика</a>

Список операций сравнения в JavaScript:

* **<** меньше
* **<=** меньше или равно
* **>** больше
* **>=** больше или равно
* **===** равно
* **!==** не равно

### <a name="логический-тип">Логический тип</a>

Наряду со строками **(string)**, целыми и рациональными числами **(number)**, логический тип **(boolean)** — это один из примитивных типов данных в JavaScript.

```
const isInfant = (age) => age < 1;
```

Пользуемся тем фактом, что любая операция — это выражение, поэтому единственной строчкой функции пишем «вернуть то значение, которое получится в результате сравнения age < 1».

В зависимости от пришедшего аргумента, сравнение будет либо истинным (true), либо ложным (false), и return вернет этот результат.

### <a name="предикаты">Предикаты</a>

Предикаты во всех языках принято именовать особым образом для простоты анализа. В JavaScript предикаты, как правило, начинаются с префикса **is**, **has** или **can**, но не ограничены этими словами. Примеры:

* _isInfant()_ — «младенец ли?»
* _hasChildren()_ — «есть ли дети?»
* _isEmpty()_ — «пустой ли?»
* _hasErrors()_ — «есть ли ошибки?»

Функция может считаться предикатом только если она возвращает **boolean**.

### <a name="комбинирование">Комбинирование логических операций</a>

Логические операции — это выражения. Значит, логические операции можно комбинировать с другими выражениями.

Например, мы хотим проверить четность числа, то есть кратность двум. В программировании используют такой подход:

* проверяют остаток от деления на 2:
* если остаток 0, то число было четным
* если остаток не 0, то число было нечетным

**Остаток от деления** — простая, но очень важная концепция в арифметике, алгебре, и даже в теории чисел и криптографии. Идея проста: нужно разделить число на несколько равных групп, и если в конце что-то останется — это и есть остаток от деления.

Делим конфеты поровну между людьми:

* 7 конфет, 2 человека: 2 x 3 + остаток 1. Значит, 7 не кратно 2.
* 21 конфету, 3 человека: 3 x 7 + остаток 0. Значит, 21 кратно 3.
* 19 конфет, 5 человек: 5 x 3 + остаток 4. Значит, 19 не кратно 5.

Оператор **%** вычисляет остаток от деления (не путайте с делением):

```
7 % 2;  // 1
21 % 3; // 0
19 % 5; // 4
```

Напишем функцию проверки четности:

```
const isEven = (number) => number % 2 === 0;

isEven(10); // true
isEven(3);  // false
```

В одном выражении мы скомбинировали логический оператор **===** (проверка равенства) и арифметический оператор **%**.

Приоритет арифметических операций выше логических. Значит, сначала вычисляется арифметическое выражение **number % 2**, затем результат участвует в логическом сравнении.

Словами это можно расшифровать так: _«вычислить остаток от деления числа number на 2 и сравнить, равен ли остаток нулю; затем вернуть результат проверки равенства»_.

### <a name="операторы">Логические операторы</a>

Как вы знаете, некоторые сайты при регистрации хотят пароль от 8 до 20 символов в длину. Честно говоря, это странное ограничение, но что поделать. В математике мы бы написали 8 < x < 20 (где x это длина конкретного пароля), но в JavaScript такой трюк не пройдет. Нам придется сделать два отдельных логических выражения и соединить их специальным оператором «И»:

_Пароль длиннее 8 символов **И** пароль короче 20 символов._

**&&** - означает «И» (в математической логике это называют _конъюнкцией_). Все выражение считается истинным только в том случае, когда истинен каждый операнд — каждое из составных выражений. Иными словами, **&&** означает «и то, и другое». Оператор **&&** обладает большим приоритетом, чем оператор **||**.

Кроме **&&**, часто используется оператор **||** — «ИЛИ» (_дизъюнкция_). Он означает «или то, или другое, или оба». Операторы можно комбинировать в любом количестве и любой последовательности, но когда одновременно встречаются **&&** и **||**, то приоритет лучше задавать скобками.

**ИЛИ ||**

   A   |   B   |  A || B
-------|:-----:|:--------:
TRUE   | TRUE  |  TRUE
TRUE   | FALSE |  TRUE
FALSE  | TRUE  |  TRUE
FALSE  | FALSE |  FALSE

Область математики, в которой изучаются логические операторы, называется _булевой алгеброй_. Ниже (и выше) показаны _«таблицы истинности»_ — по ним можно определить, каким будет результат применения оператора:

**И &&**

   A   |   B   |  A && B
-------|:-----:|:--------:
TRUE   | TRUE  |  TRUE
TRUE   | FALSE |  FALSE
FALSE  | TRUE  |  FALSE
FALSE  | FALSE |  FALSE

Наряду с _конъюнкцией_ (И) и _дизъюнкцией_ (ИЛИ), часто используется операция **«отрицание»**. Отрицание меняет логическое значение на противоположное. В программировании ему соответствует унарный оператор **!**.

**Отрицание** — мощный инструмент, который позволяет лаконично выражать задуманные правила в коде без необходимости писать новые функции.

Отрицание работает следующим образом:

1. Сначала приводит аргумент к логическому типу _true_ или _false_
2. Затем возвращает противоположное значение

Опертор **НЕ (!)** является наивысшим из всех логических операторов и _будет выполняться первым_ (то есть перед && или ||). В логике двойное отрицание подобно отсутствию отрицания вообще.

```
isEven(10);   // true
!isEven(10);  // false
!!isEven(10); // true
```

### <a name="результат-операций">Результат логических операций</a>

Что будет напечатано на экран?

```
console.log(0 || 1); // Правильный ответ: 1
```

Оператор **ИЛИ** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в _true_.

Ниже пример с оператором **И**:

```
console.log(0 && 1); // => 0
```

Оператор И работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в _false_.

В JavaScript есть два простых правила, по которым происходят преобразования:

1. **0, '' (пустая строка), undefined, NaN, null** приводятся к false. Эти значения называют _falsy_.
2. Все остальное приводится к _true_

Этим активно пользуются в разработке, например, для определения значения по умолчанию:

```
const value = name || '';

// Примеры
234 || ''; // 234
'hexlet' || ''; // hexlet
undefined || ''; // ''
```

Если _name_ примет одно из falsy-значений, константе _value_ будет присвоена пустая строка. В этом случае в последующем коде мы сможем работать с _value_ как со строкой.

Но здесь есть потенциальный баг. Если _name_ содержит falsy-значение, а присваивание константе _value_ значений типа 0, undefined, NaN или null допустимо, то код выше начнет работать неверно:

```
// Упс
false || ''; // ''
0 || ''; // ''
undefined || ''; // ''
```

Мы рассмотрели операторы сравнения === и !== и упомянули, что в JavaScript так же есть операторы == и !=, но их не стоит использовать. Отличия как раз заключаются в преобразовании типов:

```
console.log('' === false); // => false
console.log('' == false);  // => true
```

Пустая строка и false — это разные значения, поэтому оператор **===** говорит «ложь! они не равны!». Но оператор **==** преобразует типы, и с его точки зрения пустая строка и false равны. Это преобразование неявное, поэтому по возможности избегайте операторов **==** и **!=**.

### <a name="ошибка-выбора">Ошибка выбора</a>

Представьте себе задачу, в которой нам нужно проверить, что значение равно либо одному, либо другому. Например, переменная _value_ должна содержать одно из двух значений: _first_ или _second_. Начинающие разработчики иногда записывают это выражение так:

```
value === ('first' || 'second') // Не верно!
```

Правильная проверка:

```
value === 'first' || value === 'second' // Верно!
```


## <a name="условные-конструкции">Условные конструкции</a>

Условные конструкции позволяют изменить поведение программы в зависимости от проверяемых условий. Благодаря им у нас появляется возможность писать сложные программы, ведущие себя по-разному в зависимости от ситуации.

### <a name="if">if</a>

**if** — конструкция языка, управляющая порядком выполнения инструкций. В скобках ей передается выражение-предикат, а затем описывается блок кода в фигурных скобках. **Этот блок кода будет выполнен, только если предикат — истина**.

Если предикат — ложь, то блок кода в фигурных скобках пропускается, и функция продолжает свое выполнение дальше.

### <a name="else">else</a>
Добавим ключевое слово **else** и новый блок с фигурными скобками. Этот блок выполнится, только если условие в _if_ — ложь.

Существует два способа оформления конструкции **if-else**. С помощью отрицания можно изменить порядок блоков. 

Какой способ предпочтительнее? Человеческому мозгу проще мыслить прямолинейно, а не через отрицание. Старайтесь выбирать проверку, которая не содержит отрицаний, и подстраивайте содержимое блоков под нее.

### <a name="else-if">else if</a>

```
const getTypeOfSentence = (sentence) => {
  const lastChar = sentence[sentence.length - 1];
  let sentenceType;

  if (lastChar === '?') {
    sentenceType = 'question';
  } else if (lastChar === '!') {
    sentenceType = 'exclamation';
  } else {
    sentenceType = 'normal';
  }

  return `Sentence is ${sentenceType}`;
};

getTypeOfSentence('Who?'); // Sentence is question
getTypeOfSentence('No');   // Sentence is normal
getTypeOfSentence('No!');  // Sentence is exclamation
```

Теперь все условия выстроены в единую конструкцию. **else if** — это «если не выполнено предыдущее условие, но выполнено текущее». Получается такая схема:

* если последний символ это **?**, то _'question'_
* иначе, если последний символ это **!**, то _'exclamation'_
* иначе _'normal'_

Выполнится только один из блоков кода, относящихся ко всей конструкции _if_.

### <a name="тернарный">Тернарный оператор</a>

В JavaScript существует конструкция, которая по своему действию аналогична конструкции if-else, но при этом является выражением. Она называется **тернарный оператор**.

Тернарный оператор — единственный в своем роде оператор, требующий три операнда:

```
const abs = (number) => {
  return number >= 0 ? number : -number;
};
```

Общий паттерн выглядит так:

```
<predicate> ? <expression on true> : <expression on false>
```

Сокращенный вариант функции abs() выглядит так:

```
const abs = (number) => (number >= 0 ? number : -number);
```

Обратите внимание на скобки вокруг тернарника. Они не обязательны, но линтер настоятельно рекомендует их ставить, во избежание неоднозначностей.

Было:

```
const getTypeOfSentence = (sentence) => {
  const lastChar = sentence.slice(-1);

  if (lastChar === '?') {
      return 'question';
  }

  return 'normal';
};
```

Стало:

```
const getTypeOfSentence = (sentence) => {
  const lastChar = sentence.slice(-1);

  return (lastChar === '?') ? 'question' : 'normal';
};

getTypeOfSentence('Hodor');  // normal
getTypeOfSentence('Hodor?'); // question
```

### <a name="switch">Конструкция Switch</a>

Многие языки в дополнение к условной конструкции _if_ включают в себя **switch**. Это специализированная версия _if_, созданная для некоторых особых ситуаций. Например, ее имеет смысл использовать там, где есть цепочка _if else_ с проверками на равенство.

Эта составная проверка обладает одной отличительной чертой: каждая ветка здесь — это проверка значения переменной status. Switch позволяет записать этот код короче и выразительнее:

```
switch (status) {
  case 'processing': // status === 'processing' (строгое соответствие)
    // Делаем раз
    break;
  case 'paid': // status === 'paid'
    // Делаем два
    break;
  case 'new': // status === 'new'
    // Делаем три
    break;
  default: // else
    // Делаем четыре
}
```

**Свитч** — довольно сложная конструкция с точки зрения количества элементов, из которых она состоит:

* Внешнее описание, в которое входит ключевое слово **switch**. Переменная, по значениям которой **switch** будет выбирать поведение. И фигурные скобки для вариантов выбора.
* Конструкции **case** и **default**, внутри которых описывается поведение для разных значений рассматриваемой переменной. Каждый **case** соответствует _if_ в примере выше. **default** – это особая ситуация, соответствующая ветке _else_ в условных конструкциях. Как _else_, указывать **default** не обязательно _(но линтер всегда его просит)_.
* **break** нужен для предотвращения _«проваливания»_. Если его не указать, то после выполнения нужного **case** выполнение перейдет к следующему **case**, и так либо до ближайшего **break**, либо до конца **switch**.

Фигурные скобки в **switch** не определяют блок кода, как это было в других местах. Внутри допустим только тот синтаксис, который показан выше. То есть там можно использовать **case** или **default**. А вот внутри каждого **case (и default)** ситуация другая. Здесь можно выполнять любой произвольный код.

Иногда результат, полученный внутри **case**, — это конец выполнения функции, содержащей **switch**. В таком случае его нужно как-то вернуть наружу. Для решения этой задачи есть два способа:

* Первый. Создать переменную перед _switch_, заполнить ее в _case_ и затем, в конце, вернуть значение этой переменной наружу.
* Второй способ проще и короче. Вместо создания переменной, _case_ позволяет внутри себя делать обычный возврат из функции. А так как после **return** никакой код не выполняется, то мы можем избавиться от _break_.

## <a name="циклы">Циклы</a>

**Циклы** - одна из самых сложных базовых тем в программировании. Они нужны для выполнения повторяющихся действий. 

_Алгоритм_ — это последовательность действий (инструкций), которая приводит нас к некоему ожидаемому результату. В принципе, это описание подходит под любую программу, но под алгоритмами обычно понимается что-то более специфичное.

Когда все же нужны циклы, а когда можно обойтись без них? Физически невозможно обойтись без циклов тогда, когда алгоритм решения задачи требует повторения каких-то действий, и количество этих операций заранее неизвестно.

### <a name="while">Цикл while</a>

**Цикл while** состоит из трех элементов:

* **Ключевое слово while**. Несмотря на схожесть с вызовом функций, это не вызов функции.
* **Предикат**. Условие, которое указывается в скобках после _while_. Это условие вычисляется и проверяется перед выполнением тела цикла на каждой итерации.
* **Тело цикла**. Блок кода в фигурных скобках. Этот блок аналогичен блоку кода в функциях. Все, что определено внутри этого блока (константы или переменные), видно только внутри этого блока.

```
while (i <= lastNumber) {
  console.log(i);
  i = i + 1;
}
```

_Конструкция читается так_: «пока истинно условие (предикат) **i <= lastNumber** делать то, что указано в теле цикла».

_Самое главное в цикле — завершение его работы (выход из цикла)_. Процесс, который порождает цикл, должен в конце концов остановиться. Обычно задача сводится к введению переменной, называемой «счетчиком цикла». Сначала счетчик инициализируется, то есть ему задается начальное значение. Затем в условии цикла проверяется, достиг ли счетчик своего предельного значения. И, наконец, счетчик меняет свое значение _i = i + 1_.

### <a name="сахар">Синтаксический сахар</a>

Подобные конструкции **index = index + 1** в JavaScript используются довольно часто, поэтому создатели языка добавили сокращенный вариант записи: **index += 1**. Такие сокращения принято называть синтаксическим сахаром, потому что они делают процесс написания кода немного проще и приятнее, «подслащивая» его.

Существуют сокращенные формы для всех арифметических операций и для конкатенации строк:

* a = a + 1 → **a += 1**
* a = a - 1 → **a -= 1**
* a = a * 2 → **a *= 2**
* a = a / 1 → **a /= 1**
* a = a + 'foo' → **a += 'foo'**

### <a name="агрегация">Агрегация данных</a>

Отдельный класс задач, который не может обойтись без циклов, называется **агрегированием данных**. К таким задачам относятся поиск максимального, минимального, суммы, среднего арифметического и т.п. Их главная особенность в том, что результат зависит от всего набора данных. Для расчета суммы нужно сложить **все** числа, для вычисления максимального нужно сравнить **все** числа.

В математике существует понятие **нейтральный элемент** операции (у каждой операции свой элемент). Это понятие имеет очень простой смысл. Операция с этим элементом не изменяет то значение, над которым проводится операция. В сложении любое число плюс ноль дает само число. При вычитании – то же самое. Даже у конкатенации есть нейтральный элемент – это пустая строка: **''**.

Агрегация применяется не только к числам, но и к строкам. Это такие задачи, в которых строка формируется динамически, то есть заранее неизвестно, какого она размера и что будет содержать.

### <a name="формирование-строк">Формирование строк</a>

Еще одно использование циклов – формирование строк. Подобная задача нередко встречается в веб-программировании. Она сводится к обычной агрегации с применением интерполяции или конкатенации.

Есть одна задача, крайне популярная среди людей, проводящих собеседования, это переворот строки. Ее можно решить множеством разных способов, но именно посимвольный перебор считается самым базовым.

Общая идея переворота состоит в следующем: нужно брать символы по очереди с начала строки и соединять их в обратном порядке.

```
const reverse = (str) => {
  let i = 0;

  // Нейтральный элемент для строк это пустая строка
  let result = '';

  while (i < str.length) {
    // Соединяем в обратном порядке
    result = `${str[i]}${result}`;

    // То же самое через конкатенацию
    // result = str[i] + result;

    i = i + 1;
  }

  return result;
};

const name = 'Bran';
reverse(name); // narB

// Проверка нейтрального элемента
reverse(''); // ''
```

Единственный возможно сложный момент в этом коде – прочувствовать, как собирается сама строка. Так как каждый следующий символ прикрепляется к результирующей строке слева, то, в конечном итоге, строка оказывается перевернута.

### <a name="условия-внутри">Условия внутри тела цикла</a>

Тело цикла, как и тело функции — это место выполнения инструкций. Значит, мы можем использовать внутри него все изученное ранее, например — условные конструкции.

Работа с циклами обычно сводится к двум сценариям:

* Агрегация. Накопление результата во время итераций и работа с ним после цикла. Переворот строки как раз относится к такому варианту.
* Выполнение цикла до достижения необходимого результата и выход. Например, задача поиска простых чисел. Напомним, что простое число — это число, которое делится без остатка только на себя и на единицу.

_Рассмотрим простой алгоритм проверки простоты числа_. Будем делить искомое число _x_ на все числа из диапазона от двух до _x - 1_ и смотреть остаток от деления. Если в этом диапазоне не найден делитель, который делит число _x_ без остатка, значит, перед нами простое число.

Если задуматься, то можно заметить, что достаточно проверять числа не до **x - 1**, а до половины числа. Например, **11 не делится на 2, 3, 4, 5**. Но и дальше гарантированно **не будет делиться на числа больше своей половины**. Значит, можно провести небольшую оптимизацию и проверять деление только до **x / 2**.

```
const isPrime = (number) => {
  if (number < 2) {
    return false;
  }

  let divider = 2;

  while (divider <= number / 2) {
    if (number % divider === 0) {
      return false;
    }

    divider += 1;
  }

  return true;
}

isPrime(1); // false
isPrime(2); // true
isPrime(3); // true
isPrime(4); // false
```

Алгоритм построен таким образом, что если во время последовательного деления на числа до x / 2 находится хоть одно, которое делит без остатка, то переданный аргумент — не простое число, а значит, дальнейшие вычисления не имеют смысла. В этом месте стоит возврат false.

И только если цикл отработал целиком, можно сделать вывод, что число — простое, так как не было найдено ни одного числа, которое делит число без остатка.

### <a name="инкремент-декремент">Инкремент и декремент</a>

**Инкремент ++** и **декремент --**, очень часто встречаются вместе с циклами. Эти унарные операции увеличивают и уменьшают на единицу число, записанное в переменную.

Префиксная форма:

```
let i = 0;

i++; // 0
i++; // 1

i--; // 2
i--; // 1
```

Постфиксная форма: 

```
let i = 0;

++i; // 1
++i; // 2

--i; // 1
--i; // 0
```

В отличие от всех остальных операций, которые не имеют побочных эффектов и просто возвращают новое значение, инкремент и декремент не только возвращают значение, но и **изменяют** значение переменной.

* При использовании префиксной нотации сначала происходит изменение переменной, а потом возврат. 
* При использовании постфиксной нотации — наоборот: можно считать, что сначала происходит возврат, а потом изменение переменной. 

Правило работает одинаково для инкремента и декремента.

Для простоты рассмотрим только инкремент:

```
let x = 5;

console.log(++x); // => 6
console.log(x);   // => 6

console.log(x++); // => 6
console.log(x);   // => 7
```

Что происходит?

* Вывели на экран _++x_. Это префиксный инкремент, поэтому сначала значение переменной увеличилось на 1, потом результат вернулся и вывелся на экран.
* Так как значение изменилось, console.log(x) вывел 6.
* Теперь выводим на экран _x++_. Это постфиксный инкремент, поэтому возвращено значение, содержавшееся в переменной до ее увеличения на 1.
* Так как значение изменилось, console.log(x) вывел 7.

Рекомендации по использованию:

* Никогда не мешайте в рамках одного выражения операции/функции без побочных эффектов с операциями/функциями, обладающими побочными эффектами.
* Используйте инкремент и декремент только там, где нет разницы между префиксным и постфиксным вариантом: отдельно от всего, на своей собственной строчке кода.

### <a name="for">Цикл for</a>

Когда количество итераций известно, предпочтительнее использовать цикл for.

```
const reverseString = (str) => {
  let result = '';
  for (let i = 0; i < str.length; i += 1) {
    result = `${str[i]}${result}`;
  }

  return result;
};
```

В определении цикла for в круглых скобках есть три выражения, разделенные точкой с запятой:

1. Начальное значение счетчика. Этот код выполняется ровно один раз перед первой итерацией.
2. Предикат — условие повторения циклов. Выполняется на каждой итерации. Точно так же как и в _while_
3. Описание изменения счетчика. Этот код выполняется в конце каждой итерации.

## <a name="модули">Модули</a>

Модули могут храниться в отдельных файлах, а имена функций и констант будут уникальными только в пределах файла, но не во всей программе. И модули можно легко переиспользовать в разных проектах, без копирования и вставки.

У разных языков программирования разные подходы к этой задаче. В JavaScript он довольно простой: один файл — один модуль.

Объединение кода, расположенного в разных модулях, происходит через:

1. Экспорт чего-то из модуля

```
export const pi = 3.14;
export const e = 2.718;

export const square = (x) => {
  return x * x;
};

export const surfaceArea = (r) => {
  return 4 * pi * square(r);
};
```

Просто укажите export перед чем угодно, и это можно будет "импортировать" в другой файл. Тут мы экспортируем все. Еще один способ экспортировать несколько значений:

```
const pi = 3.14;
const e = 2.718;

const square = (x) => {
  return x * x;
};

const surfaceArea = (r) => {
  return 4 * pi * square(r);
};

export { pi, e, square, surfaceArea };
```

2. Импорт в другой модуль

Допустим, мы хотим импортировать что-то. Мы можем просто добавить названия в список:

```
import { surfaceArea, square, pi, e } from './math.js';
```

Или импортировать все сразу:

```
import * as mathematics from './math.js';
```

Часто вам требуется экспортировать из модуля что-то одно. Существует специальный механизм, который называется **"экспорт по умолчанию"**, и вы можете экспортировать с помощью него только что-то одно. Но экспортированную по умолчанию вещь проще импортировать.

Просто напишите код, как обычно, без специально указанных экспортов, а в конце выполните **export default что-нибудь**.

Импорт по умолчанию выглядит так:

```
// Без фигурных скобок
import surfaceArea from './math.js';

const surfaceOfMars = surfaceArea(3390);
```

Импорт может выглядеть так:

```
import surfaceArea, { square, e, pi } from './math.js';
```

Ключевое слово as позволяет задать псевдоним для импортируемой сущности. Благодаря этому появляется возможность импортировать элементы с одинаковыми именами:

```
import { square, e, pi } from './math.js';
import { square as square1, e as e1, pi as pi1 } from './math1.js';
```

При использовании ключевого слова **import** необходимо указать расширение файла. Пути каталогов (например, './startup/index.js') также _должны быть полностью указаны_.

Этот подход обеспечивает идентичное поведение import в среде браузера и на сервере с типовой конфигурацией.

_Ниже описан основной алгоритм, по которому нужно анализировать файл с кодом, над которым вы сейчас работаете_. Этот алгоритм не является специфичным для работы в среде Хекслета, так нужно делать в принципе:

1. Внимательно изучите все импорты, описанные в начале файла. Так вы узнаете, какие модули и функции доступны внутри вашего файла (не считая глобальных функций и модулей, которые доступны и без импорта, например, Math)
2. Попробуйте классифицировать импортируемые функции. Если импорт выглядит так **from './...'**, то есть содержит **./**, значит импортируется модуль, содержимое которого находится в текущей файловой системе. Это автоматически означает несколько вещей:
* Первое: вы всегда можете открыть этот файл и посмотреть, что там написано. 
* Второе: вы не сможете импортировать этот модуль в другой среде (ведь этого файла там нет)
3. Если **from 'name'** содержит только имя, без **./** в начале, значит, модуль подгружается либо из стандартной библиотеки _nodejs_, либо из установленных пакетов. Визуально невозможно отличить одно от другого. Попробуйте загуглить имя таким способом: **"nodejs name"**. Если в выдаче будет ссылка на официальную документацию, значит, это модуль **nodejs;** если на репозиторий _npm_ — значит, это обычный пакет, который почти наверняка лежит на гитхабе, что можно проверить таким запросом: **"github js name"**, где _"name"_ это имя пакета.