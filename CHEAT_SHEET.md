# Шпаргалка по JS

## Переменные

Для удобства анализа программы, переменные принято создавать как можно ближе к тому месту, где они используются. Переменная должна быть определена до того, как будет использована.

_let greeting = 'Hello!';_

* __let__ - ключевое слово для создания переменной. Ключевое слово **let** ставится только при создании переменной, но при изменении оно уже не используется.
* __greeting__ - имя переменной;
* __=__ - оператор присваивания;
* __'Hello!'__ - значение;

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, а также знаки **_** и **$**. При этом цифру нельзя ставить в начале.

Регистр в JavaScript имеет важное значение.

## Константы

Имена констант с заранее известным значением принято записывать в верхнем регистре и отделять нижним подчеркиванием.

*const BOX_WIDTH = 55;*

Имена констант со значением присвоенным в процессе выполения программы.

_const euros = 1000;_

Если значение у переменной не меняется, то мы имеем дело с константой. Менять содержимое константы нельзя. Переменные жизненно необходимы только в одном случае (во всех остальных гарантированно можно обойтись без них) – при работе с циклами.

Предпочтительно использовать только константы и добавлять переменные только тогда, когда без них нельзя обойтись.

## Выражения в определениях

_let dollarsCount = 50 * 1.25;_ - справа от знака равно находится выражение.

Любая строка — выражение. Конкатенация строк — тоже выражение. Когда интерпретатор видит выражение, он обрабатывает его и генерирует результат — значение выражения.

__Всё это выражения:__
    Выражения    | Результат
-----------------|:-------: 
62.5             |   62.5 
50 * 1.25        |   62.5
120 / 10 * 2     |   24
'hello'          |   hello
'Good' + 'will'  |   Goodwill

Любая переменная может быть частью любого выражения. В момент вычисления, вместо имени переменной подставляется ее значение.

## Стили именования

* _kebab-case_ — составные части переменной разделяются дефисом. Например: my-super-var.
* *snake_case* — для разделения используется подчеркивание. Например: my_super_var.
* _CamelCase_ — каждое слово в переменной пишется с заглавной буквы. Например: MySuperVar.
* _lowerCamelCase_ — каждое слово в переменной пишется с заглавной буквы, кроме первого.

В Javascript используется **CamelCase** и его вариация **lowerCamelCase**, при котором первая буква первого слова — строчная. Именно **lowerCamelCase** применяется для переменных.

### Магические числа

**Magic Numbers** (магические числа) - числа, происхождение которых невозможно понять без глубокого знания происходящего внутри данного участка кода.

## Интерполяция

Интерполяция работает только со строками в бектиках. Это символ **`**.

_const firstName = 'Joffrey';_

_const greeting = 'Hello';_

_console.log(`${greeting}, ${firstName}!`);_

Почти во всех языках интерполяция предпочтительнее конкатенации для объединения строк. Строка при этом получается склеенная, и внутри нее хорошо просматриваются пробелы и другие символы. Во-первых, интерполяция позволяет не путать строки с числами (из-за знака **+**), а во-вторых, так гораздо проще (после некоторой практики) понимать строку целиком.

## Извлечение символов из строки

_const firstName = 'Tirion';_

_console.log(firstName[0]);_

Квадратные скобки с цифрой — это специальный синтаксис извлечения символа из строки. Цифра называется индексом — позицией символа внутри строки. Индексы начинаются с 0 почти во всех языках программирования — поэтому, чтобы получить первый символ, нужно указать индекс 0. Индекс последнего элемента равен длине строки минус единица.

Индексом может быть не только конкретное число, но и значение переменной. 

Обращение по несуществующему индексу вернет значение undefined.

## Типы данных

Значение в JavaScript всегда относится к данным определённого типа. Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число.

Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.

JavaScript позволяет узнать тип данных с помощью оператора **typeof**.

_typeof 3;      // number_

_typeof 'Game'; // string_

### 1. Число

Числовой тип данных **(number)** представляет как целочисленные значения, так и числа с плавающей точкой.

В математике существуют разные виды чисел, например, _натуральные_ – это целые числа от одного и больше, или _рациональные_ – это числа с точкой, например 0.5.

Для нас, как для разработчиков, важно понимать, что операции с плавающими числами неточны (эту точность можно регулировать), а значит при решении задач, связанных с подобными числами, необходимо прибегать к специальным трюкам, которые позволяют добиться необходимой точности.

Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: **Infinity**, **-Infinity** и **NaN**. Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.

* _Infinity_ представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
* _NaN_ означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции. Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (есть только одно исключение: NaN ** 0 равно 1).

### 2. BigInt

Тип _BigInt_ был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:

_const bigInt = 1234567890123456789012345678901234567890n;_ - символ "n" в конце означает, что это BigInt

### 3. Строка

Строка **(string)** в JavaScript должна быть заключена в кавычки. В JavaScript существует три типа кавычек:
1. Двойные кавычки: "Привет".
2. Одинарные кавычки: 'Привет'.
3. Обратные кавычки: `Привет`.

Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.

Обратные же кавычки имеют расширенную функциональность. Они позволяют использовать интерполяцию **${…}**.
Выражение внутри **${…}** вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную, или выражение (1 + 2), или что-то более сложное.

### 4. Булевый (логический) тип

Булевый тип **(boolean)** может принимать только два значения: _true_ (истина) и _false_ (ложь).

Такой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно», а false значит «нет, не правильно».

Булевые значения также могут быть результатом сравнений: _4 > 1 - true_

### 5. Значение «null»

Специальное значение **null** не относится ни к одному из типов, описанных выше.

Оно формирует отдельный тип, который содержит только значение **null**. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

### 6. Значение «undefined»

Специальное значение **undefined** также стоит особняком. Оно означает, что «значение не было присвоено». 

Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет **undefined**.

### 7. Символ

Тип **symbol** (символ) используется для создания уникальных идентификаторов в объектах. 

### 8. Объект (только этот тип данных не является примитивным)

Тип **object** (объект) – особенный.

Все остальные типы называются _«примитивными»_, потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

## Преобразование типов

В программировании регулярно встречаются задачи, когда один тип данных нужно преобразовать в другой — например, при работе с формами на сайтах. Данные формы всегда приходят в текстовом виде, даже если значение — число.

**parseInt()** — это функция, в которую передается значение, чтобы его преобразовать. Функция ведет себя подобно арифметическим операциям, но делает особые действия. Вот еще несколько примеров:

_const value = '0';_

// Внутри скобок можно указывать переменную

_const number1 = parseInt(value);_

_console.log(number1); // => 0_
===

// Или конкретное значение

_const number2 = parseInt('10');_

_console.log(number2); // => 10_
===

// Если преобразуется число с плавающей точкой, то отбрасывается вся дробная часть

_const number5 = parseInt(3.5);_

_console.log(number5); // => 3_
===

С помощью **parseFloat()** точно так же можно преобразовать строку в число с плавающей точкой:

_const value3 = parseFloat('0.5');_

_console.log(value3); // 0.5_

## Неизменяемость и примитивные типы

Что произойдет, если попытаться изменить символ в строке?

_let firstName = 'Alexander';_

// Код выполнится без ошибок

_firstName[0] = 'B';_

_console.log(firstName); // => Alexander_

Как это ни странно, но значение переменной firstName останется прежним, хотя код выполнится без ошибок. Так происходит из-за неизменяемости примитивных типов в JavaScript — язык не дает никакой физической возможности поменять строку. Неизменяемость примитивных типов важна по многим причинам, ключевая — производительность. Но что делать, если нам действительно нужно ее изменить? Для этого и существуют переменные.

Есть большая разница между изменением значения переменной и изменением самого значения. Примитивные типы в JavaScript поменять нельзя, а заменить значение переменной — без проблем.

## Слабая типизация

JavaScript — это язык со **слабой типизацией**. Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию, когда это кажется разумным.

_console.log(1 + '7');_ // => 17

В языках со **строгой типизацией** сложить число со строкой не получится.

JavaScript был создан для интернета, а в интернете вся информация — это строки. Даже когда вы вводите на сайте номер телефона или год рождения, на сервер эта информация поступает не как числа, а как строки. Поэтому авторы языка решили, что автоматически преобразовывать типы — правильно и удобно.

