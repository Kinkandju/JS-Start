# Шпаргалка по JS

## Переменные

Для удобства анализа программы, переменные принято создавать как можно ближе к тому месту, где они используются. Переменная должна быть определена до того, как будет использована.

_let greeting = 'Hello!';_

* __let__ - ключевое слово для создания переменной. Ключевое слово **let** ставится только при создании переменной, но при изменении оно уже не используется.
* __greeting__ - имя переменной;
* __=__ - оператор присваивания;
* __'Hello!'__ - значение;

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, а также знаки **_** и **$**. При этом цифру нельзя ставить в начале.

Регистр в JavaScript имеет важное значение.

## Константы

Имена констант с заранее известным значением принято записывать в верхнем регистре и отделять нижним подчеркиванием.

*const BOX_WIDTH = 55;*

Имена констант со значением присвоенным в процессе выполения программы.

_const euros = 1000;_

Если значение у переменной не меняется, то мы имеем дело с константой. Менять содержимое константы нельзя. Переменные жизненно необходимы только в одном случае (во всех остальных гарантированно можно обойтись без них) – при работе с циклами.

Предпочтительно использовать только константы и добавлять переменные только тогда, когда без них нельзя обойтись.

## Выражения в определениях

_let dollarsCount = 50 * 1.25;_ - справа от знака равно находится выражение.

Любая строка — выражение. Конкатенация строк — тоже выражение. Когда интерпретатор видит выражение, он обрабатывает его и генерирует результат — значение выражения.

__Всё это выражения:__
    Выражения    | Результат
-----------------|:-------: 
62.5             |   62.5 
50 * 1.25        |   62.5
120 / 10 * 2     |   24
'hello'          |   hello
'Good' + 'will'  |   Goodwill

Любая переменная может быть частью любого выражения. В момент вычисления, вместо имени переменной подставляется ее значение.

## Стили именования

* _kebab-case_ — составные части переменной разделяются дефисом. Например: my-super-var.
* *snake_case* — для разделения используется подчеркивание. Например: my_super_var.
* _CamelCase_ — каждое слово в переменной пишется с заглавной буквы. Например: MySuperVar.
* _lowerCamelCase_ — каждое слово в переменной пишется с заглавной буквы, кроме первого.

В Javascript используется **CamelCase** и его вариация **lowerCamelCase**, при котором первая буква первого слова — строчная. Именно **lowerCamelCase** применяется для переменных.

### Магические числа

**Magic Numbers** (магические числа) - числа, происхождение которых невозможно понять без глубокого знания происходящего внутри данного участка кода.

## Интерполяция

Интерполяция работает только со строками в бектиках. Это символ **`**.

_const firstName = 'Joffrey';_

_const greeting = 'Hello';_

_console.log(`${greeting}, ${firstName}!`);_

Почти во всех языках интерполяция предпочтительнее конкатенации для объединения строк. Строка при этом получается склеенная, и внутри нее хорошо просматриваются пробелы и другие символы. Во-первых, интерполяция позволяет не путать строки с числами (из-за знака **+**), а во-вторых, так гораздо проще (после некоторой практики) понимать строку целиком.

## Извлечение символов из строки

_const firstName = 'Tirion';_

_console.log(firstName[0]);_

Квадратные скобки с цифрой — это специальный синтаксис извлечения символа из строки. Цифра называется индексом — позицией символа внутри строки. Индексы начинаются с 0 почти во всех языках программирования — поэтому, чтобы получить первый символ, нужно указать индекс 0. Индекс последнего элемента равен длине строки минус единица.

Индексом может быть не только конкретное число, но и значение переменной. 

Обращение по несуществующему индексу вернет значение undefined.

## Типы данных

Значение в JavaScript всегда относится к данным определённого типа. Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число.

Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.

JavaScript позволяет узнать тип данных с помощью оператора **typeof**.

_typeof 3;      // number_

_typeof 'Game'; // string_

### 1. Число

Числовой тип данных **(number)** представляет как целочисленные значения, так и числа с плавающей точкой.

В математике существуют разные виды чисел, например, _натуральные_ – это целые числа от одного и больше, или _рациональные_ – это числа с точкой, например 0.5.

Для нас, как для разработчиков, важно понимать, что операции с плавающими числами неточны (эту точность можно регулировать), а значит при решении задач, связанных с подобными числами, необходимо прибегать к специальным трюкам, которые позволяют добиться необходимой точности.

Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: **Infinity**, **-Infinity** и **NaN**. Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.

* _Infinity_ представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
* _NaN_ означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции. Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (есть только одно исключение: NaN ** 0 равно 1).

### 2. BigInt

Тип _BigInt_ был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:

_const bigInt = 1234567890123456789012345678901234567890n;_ - символ "n" в конце означает, что это BigInt

### 3. Строка

Строка **(string)** в JavaScript должна быть заключена в кавычки. В JavaScript существует три типа кавычек:
1. Двойные кавычки: "Привет".
2. Одинарные кавычки: 'Привет'.
3. Обратные кавычки: `Привет`.

Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.

Обратные же кавычки имеют расширенную функциональность. Они позволяют использовать интерполяцию **${…}**.
Выражение внутри **${…}** вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную, или выражение (1 + 2), или что-то более сложное.

### 4. Булевый (логический) тип

Булевый тип **(boolean)** может принимать только два значения: _true_ (истина) и _false_ (ложь).

Такой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно», а false значит «нет, не правильно».

Булевые значения также могут быть результатом сравнений: _4 > 1 - true_

### 5. Значение «null»

Специальное значение **null** не относится ни к одному из типов, описанных выше.

Оно формирует отдельный тип, который содержит только значение **null**. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

### 6. Значение «undefined»

Специальное значение **undefined** также стоит особняком. Оно означает, что «значение не было присвоено». 

Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет **undefined**.

### 7. Символ

Тип **symbol** (символ) используется для создания уникальных идентификаторов в объектах. 

### 8. Объект (только этот тип данных не является примитивным)

Тип **object** (объект) – особенный.

Все остальные типы называются _«примитивными»_, потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

## Преобразование типов

В программировании регулярно встречаются задачи, когда один тип данных нужно преобразовать в другой — например, при работе с формами на сайтах. Данные формы всегда приходят в текстовом виде, даже если значение — число.

**parseInt()** — это функция, в которую передается значение, чтобы его преобразовать. Функция ведет себя подобно арифметическим операциям, но делает особые действия. Вот еще несколько примеров:

_const value = '0';_

Внутри скобок можно указывать переменную.

_const number1 = parseInt(value);_

_console.log(number1);_ // => 0

===

Или конкретное значение.

_const number2 = parseInt('10');_

_console.log(number2);_ // => 10

===

Если преобразуется число с плавающей точкой, то отбрасывается вся дробная часть.

_const number5 = parseInt(3.5);_

_console.log(number5);_ // => 3

===

С помощью **parseFloat()** точно так же можно преобразовать строку в число с плавающей точкой:

_const value3 = parseFloat('0.5');_

_console.log(value3);_ // 0.5

## Неизменяемость и примитивные типы

Что произойдет, если попытаться изменить символ в строке?

_let firstName = 'Alexander';_

Код выполнится без ошибок.

_firstName[0] = 'B';_

_console.log(firstName);_ // => Alexander

Как это ни странно, но значение переменной firstName останется прежним, хотя код выполнится без ошибок. Так происходит из-за неизменяемости примитивных типов в JavaScript — язык не дает никакой физической возможности поменять строку. Неизменяемость примитивных типов важна по многим причинам, ключевая — производительность. Но что делать, если нам действительно нужно ее изменить? Для этого и существуют переменные.

Есть большая разница между изменением значения переменной и изменением самого значения. Примитивные типы в JavaScript поменять нельзя, а заменить значение переменной — без проблем.

## Слабая типизация

JavaScript — это язык со **слабой типизацией**. Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию, когда это кажется разумным.

_console.log(1 + '7');_ // => 17

В языках со **строгой типизацией** сложить число со строкой не получится.

JavaScript был создан для интернета, а в интернете вся информация — это строки. Даже когда вы вводите на сайте номер телефона или год рождения, на сервер эта информация поступает не как числа, а как строки. Поэтому авторы языка решили, что автоматически преобразовывать типы — правильно и удобно.

## Функции и их вызов

Для выражения любой произвольной операции в программировании существует понятие функция. Функции бывают как встроенные, так и добавленные программистом.

**Функции** — одна из ключевых конструкций в программировании, без них невозможно сделать практически ничего.

Параметры (или _аргументы_) — это информация, которую функция получает при вызове. Именно на основе этой информации функция, как правило, вычисляет что-то и выдает результат.

Мы создали константу _result_ и указали интерпретатору записать в нее результат, возвращаемый функцией _length()_ при ее вызове. В этом смысле функции подобны операциям – они всегда возвращают результат своей работы.

_const result = length('Hello!');_

Запись _length('Hello!')_ означает, что вызывается функция с именем _length_, в которую был передан параметр _'Hello!'_. Функция _length()_ считает длину именно той строки, которая ей была передана.

Вызов функции всегда обозначается скобками **()**, идущими сразу за именем функции. В скобках может быть любое количество параметров, а иногда — вообще ни одного. Количество зависит от используемой функции.

_const result = pow(2, 3);_ // 2 * 2 * 2

Вызов pow(2, 3) возвращает значение 2 в 3 степени.

По большому счету, операторы и функции — это одно и то же. Ключевая разница только в том, как они записываются. Если представить (гипотетически) сложение как функцию, то она будет выглядеть так:

* Обычное сложение: _3 + 5;_ // 8
* Сложение, представленное как функция: _+(3, 5);_

Функции вызываются и возвращают результат, который затем может быть использован в дальнейших вычислениях или, например, выведен на экран.

### Математические функции

В предыдущем задании мы использовали самописную функцию **pow()**, а теперь давайте рассмотрим ее версию, встроенную в сам язык.

_Math.pow(2, 3);_ // 8

Что такое **Math**? Технически — это объект, доступный из любого места программы. Функции для математических операций вызываются через **Math.**.

Функция _Math.pow()_, возводящая число в какую-нибудь степень, принимает два параметра: **какое число возводить** и **в какую степень возводить**. Если вызывать _pow()_ без параметров, то вернется **NaN**. Функция честно пытается выполнить возведение в степень, но если значение не передано, то интерпретатор автоматически передает ей **undefined**.

Откуда мы знаем, сколько каких параметров нужно функции **Math.pow()** и какого типа будет «возврат»? Мы заглянули в **сигнатуру** этой функции. Сигнатура определяет входные параметры и их типы, а также выходной параметр и его тип.

### Параметры по умолчанию

Рассмотрим функцию **round()**, которая округляет число с плавающей точкой:

_const result = round(10.25, 0);_ // 10

Мы передали в нее два параметра: число, которое нужно округлить, и точность округления. **0** означает, что округление будет до ближайшего целого значения.

Чаще всего нужно округлять именно до целого числа (а не до десятых, например), поэтому создатели функции **round()** сделали второй параметр _необязательным_ и задали ему внутри функции значение по умолчанию **0**. Значит, можно не указывать второй параметр, а результат будет тем же:

_const result = round(10.25);_ // 10

Если функция в JavaScript принимает необязательные параметры, то они всегда стоят после обязательных. Их количество может быть любым (это зависит от самой функции), но они всегда идут рядом и в конце списка аргументов.

### Вызов функции - выражения

В программировании выражение – нечто, возвращающее результат, который можно использовать. Математические операции (сложение, вычитание), строковые операции (конкатенация) – все это выражения.

Особенность выражений в том, что они возвращают результат, который можно, например, присвоить константе или вывести на экран.

Но не все в программировании является выражением. Определение переменной – это инструкция, она не может быть частью выражения. То есть такой код выдаст ошибку:

_10 + const sum = 1 + 5;_

Выражения можно комбинировать, получая все более сложное поведение в самых неожиданных местах и самым неожиданным образом.

Функции возвращают результат, поэтому они считаются выражениями. Из этого автоматически следует много интересного. Например, мы можем использовать вызов функции прямо в математических операциях. Все это справедливо для любых функций, например, строковых.

### Функции с переменным числом параметров

Интересная особенность некоторых функций — принимать переменное число параметров.

_Math.max(1, 10, 3);_ // 10

Функция **Math.max()** находит максимальное значение среди переданных параметров.

_Math.max([value1[, value2[, ...]]])_

Такая запись говорит о том, что эта функция принимает на вход любое число параметров (и даже может быть вызвана без них). Необязательность передаваемых параметров описывается скобками **[ ]**, точно так же описываются и опциональные параметры, у которых есть значения по умолчанию. Возможность передачи любого числа параметров зашита в этой части **[, ...]**.

### Детерминированность

Независимо от того, какой язык программирования используется, функции внутри него обладают некоторыми фундаментальными свойствами. Зная эти свойства, легче прогнозировать поведение функций, способы их тестирования и место их использования. К таким свойствам относится _детерминированность_.

Функция называется **детерминированной** тогда, когда для одних и тех же входных параметров она возвращает один и тот же результат.

Например, функция, считающая количество символов, детерминированная, в свою очередь функция, возвращающая случайное число, не является детерминированной, так как у одного и того же входа (даже если он пустой, то есть параметры не принимаются) мы получим всегда разный результат.

Детерминированность серьезно влияет на многие аспекты. Детерминированные функции удобны в работе, их легко оптимизировать, легко тестировать. Если есть возможность сделать функцию детерминированной, то лучше ее такой и сделать.

### Побочные эффекты

Что возвращает функция _console.log()?_ Ответ: что бы она ни возвращала, это значение никак не используется.

**console.log()** выводит что-то на экран, но это не возврат значения, это просто какое-то действие, которое выполняет функция. Вывод на экран и возврат значения из функции — разные и независимые операции.

С точки зрения программы вывод на экран — это так называемый **побочный эффект**. Побочным эффектом называют действия, которые изменяют внешнее окружение (среду выполнения). К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран или печать на принтере и так далее.

Побочные эффекты — один из основных источников проблем и ошибок в программных системах. Код с побочными эффектами сложен в тестировании, ненадежен. При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы (записать в базу, вывести на экран, отправить по сети и так далее).

## Стандартная библиотека

JavaScript, как и любой другой язык, поставляется с набором полезных функций. Все вместе они составляют так называемую **стандартную библиотеку**. В нее обычно входят тысячи функций, которые невозможно выучить — этого и не нужно делать.

Любой разработчик в процессе своего профессионального взросления знакомится со все более интересными функциями, решающими его задачи более элегантно, и таким образом пополняет свой арсенал.

Вот некоторые советы, как узнавать о новых функциях:

* Всегда четко отслеживайте, с чем вы сейчас работаете (какой тип данных). Почти всегда вы найдете необходимую функцию в соответствующем разделе документации — например, для работы со строками нужно изучать строковые функции;
* Периодически открывайте раздел со стандартными функциями по изучаемой тематике и просто пробегайтесь по ним, изучая сигнатуры и способы использования;
* Чаще читайте чужой код, особенно код библиотек, которые вы используете. Он весь доступен на GitHub.

У JavaScript есть свои особенности по структуре стандартной библиотеки. Так как его код может исполняться в разных средах, таких как серверное окружение или браузер, то возможности стандартной библиотеки сильно зависят от варианта использования.