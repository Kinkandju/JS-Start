# Шпаргалка по JS

## Оглавление
1. [Переменные](#переменные)
2. [Константы](#константы)
3. [Выражения в определениях](#выражения)
4. [Стили именования](#именования)
  + [Магические числа](#магия)
5. [Интерполяция](#интерполяция)
6. [Извлечение символов из строки](#извлечение)
7. [Типы данных](#типы)
  + [1. Число](#число)
  + [2. BigInt](#BigInt)
  + [3. Строка](#строка)
  + [4. Булевый (логический) тип](#булево)
  + [5. Значение «null»](#null)
  + [6. Значение «undefined»](#undefined)
  + [7. Символ](#символ)
  + [8. Объект (только этот тип данных не является примитивным)](#объект)
8. [Преобразование типов](#преобразование)
9. [Неизменяемость и примитивные типы](#неизменяемость)
10. [Слабая типизация](#типизация)
11. [Функции и их вызов](#функции)
  + [Математические функции](#Math)
  + [Параметры по умолчанию](#параметры)
  + [Вызов функции - выражения](#вызов)
  + [Функции с переменным числом параметров](#переменные-параметры)
  + [Детерминированность](#детерминированность)
  + [Побочные эффекты](#побочные)
12. [Стандартная библиотека](#библиотека)
13. [Свойства и методы](#свойства)
  + [Методы](#методы)
  + [Неизменяемость](#неизменность)
  + [Свойства и методы как выражения](#как-выражения)
  + [Цепочка вызовов](#цепочка)
14. [Определение функций](#определение)
  + [Возврат значений](#возврат)
  + [Параметры функций](#параметры-функций)
  + [Необязательные параметры функций](#необязательные-параметры)
  + [Упрощенный синтаксис функций](#упрощенный-синтаксис)
15. [Логика](#логика)
  + [Логический тип](#логический-тип)
  + [Предикаты](#предикаты)
  + [Комбинирование логических операций](#комбинирование)
  + [Логические операторы](#операторы)
  + [Результат логических операций](#результат-операций)
  + [Ошибка выбора](#ошибка-выбора)
16. [Условные конструкции](#условные-конструкции)
  + [if](#if)
  + [else](#else)
  + [else if](#else-if)


## <a name="переменные">Переменные</a>

Для удобства анализа программы, переменные принято создавать как можно ближе к тому месту, где они используются. Переменная должна быть определена до того, как будет использована.

```
let greeting = 'Hello!';
```

* __let__ - ключевое слово для создания переменной. Ключевое слово **let** ставится только при создании переменной, но при изменении оно уже не используется.
* __greeting__ - имя переменной;
* __=__ - оператор присваивания;
* __'Hello!'__ - значение;

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, а также знаки **_** и **$**. При этом цифру нельзя ставить в начале.

Регистр в JavaScript имеет важное значение.

## <a name="константы">Константы</a>

Имена констант с заранее известным значением принято записывать в верхнем регистре и отделять нижним подчеркиванием.

```
const BOX_WIDTH = 55;
```

Имена констант со значением присвоенным в процессе выполения программы.

```
const euros = 1000;
```

Если значение у переменной не меняется, то мы имеем дело с константой. Менять содержимое константы нельзя. Переменные жизненно необходимы только в одном случае (во всех остальных гарантированно можно обойтись без них) – при работе с циклами.

Предпочтительно использовать только константы и добавлять переменные только тогда, когда без них нельзя обойтись.

## <a name="выражения">Выражения в определениях</a>

```
let dollarsCount = 50 * 1.25; - справа от знака равно находится выражение.
```

Любая строка — выражение. Конкатенация строк — тоже выражение. Когда интерпретатор видит выражение, он обрабатывает его и генерирует результат — значение выражения.

__Всё это выражения:__
    Выражения    | Результат
-----------------|:-------: 
62.5             |   62.5 
50 * 1.25        |   62.5
120 / 10 * 2     |   24
'hello'          |   hello
'Good' + 'will'  |   Goodwill

Любая переменная может быть частью любого выражения. В момент вычисления, вместо имени переменной подставляется ее значение.

## <a name="именования">Стили именования</a>

* _kebab-case_ — составные части переменной разделяются дефисом. Например: my-super-var.
* *snake_case* — для разделения используется подчеркивание. Например: my_super_var.
* _CamelCase_ — каждое слово в переменной пишется с заглавной буквы. Например: MySuperVar.
* _lowerCamelCase_ — каждое слово в переменной пишется с заглавной буквы, кроме первого.

В Javascript используется **CamelCase** и его вариация **lowerCamelCase**, при котором первая буква первого слова — строчная. Именно **lowerCamelCase** применяется для переменных.

### <a name="магия">Магические числа</a>

**Magic Numbers** (магические числа) - числа, происхождение которых невозможно понять без глубокого знания происходящего внутри данного участка кода.

## <a name="интерполяция">Интерполяция</a>

Интерполяция работает только со строками в бектиках. Это символ **`**.

```
const firstName = 'Joffrey';
const greeting = 'Hello';

console.log(`${greeting}, ${firstName}!`);
```

Почти во всех языках интерполяция предпочтительнее конкатенации для объединения строк. Строка при этом получается склеенная, и внутри нее хорошо просматриваются пробелы и другие символы. Во-первых, интерполяция позволяет не путать строки с числами (из-за знака **+**), а во-вторых, так гораздо проще (после некоторой практики) понимать строку целиком.

## <a name="извлечение">Извлечение символов из строки</a>

```
const firstName = 'Tirion';

console.log(firstName[0]);
```

Квадратные скобки с цифрой — это специальный синтаксис извлечения символа из строки. Цифра называется индексом — позицией символа внутри строки. Индексы начинаются с 0 почти во всех языках программирования — поэтому, чтобы получить первый символ, нужно указать индекс 0. Индекс последнего элемента равен длине строки минус единица.

Индексом может быть не только конкретное число, но и значение переменной. 

Обращение по несуществующему индексу вернет значение undefined.

## <a name="типы">Типы данных</a>

Значение в JavaScript всегда относится к данным определённого типа. Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число.

Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.

JavaScript позволяет узнать тип данных с помощью оператора **typeof**.

```
typeof 3;      // number
typeof 'Game'; // string
```

### <a name="число">1. Число</a>

Числовой тип данных **(number)** представляет как целочисленные значения, так и числа с плавающей точкой.

В математике существуют разные виды чисел, например, _натуральные_ – это целые числа от одного и больше, или _рациональные_ – это числа с точкой, например 0.5.

Для нас, как для разработчиков, важно понимать, что операции с плавающими числами неточны (эту точность можно регулировать), а значит при решении задач, связанных с подобными числами, необходимо прибегать к специальным трюкам, которые позволяют добиться необходимой точности.

Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: **Infinity**, **-Infinity** и **NaN**. Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.

* _Infinity_ представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
* _NaN_ означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции. Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (есть только одно исключение: NaN ** 0 равно 1).

### <a name="BigInt">2. BigInt</a>

Тип _BigInt_ был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:

```
const bigInt = 1234567890123456789012345678901234567890n; - символ "n" в конце означает, что это BigInt
```

### <a name="строка">3. Строка</a>

Строка **(string)** в JavaScript должна быть заключена в кавычки. В JavaScript существует три типа кавычек:
1. Двойные кавычки: "Привет".
2. Одинарные кавычки: 'Привет'.
3. Обратные кавычки: `Привет`.

Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.

Обратные же кавычки имеют расширенную функциональность. Они позволяют использовать интерполяцию **${…}**.
Выражение внутри **${…}** вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную, или выражение (1 + 2), или что-то более сложное.

### <a name="булево">4. Булевый (логический) тип</a>

Булевый тип **(boolean)** может принимать только два значения: _true_ (истина) и _false_ (ложь).

Такой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно», а false значит «нет, не правильно».

Булевые значения также могут быть результатом сравнений: 
``` 
4 > 1 - true 
```

### <a name="null">5. Значение «null»</a>

Специальное значение **null** не относится ни к одному из типов, описанных выше.

Оно формирует отдельный тип, который содержит только значение **null**. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

### <a name="undefined">6. Значение «undefined»</a>

Специальное значение **undefined** также стоит особняком. Оно означает, что «значение не было присвоено». 

Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет **undefined**.

### <a name="undefined">7. Символ</a>

Тип **symbol** (символ) используется для создания уникальных идентификаторов в объектах. 

### <a name="объект">8. Объект (только этот тип данных не является примитивным)</a>

Тип **object** (объект) – особенный.

Все остальные типы называются _«примитивными»_, потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

## <a name="преобразование">Преобразование типов</a>

В программировании регулярно встречаются задачи, когда один тип данных нужно преобразовать в другой — например, при работе с формами на сайтах. Данные формы всегда приходят в текстовом виде, даже если значение — число.

**parseInt()** — это функция, в которую передается значение, чтобы его преобразовать. Функция ведет себя подобно арифметическим операциям, но делает особые действия. Вот еще несколько примеров:

```
const value = '0';
```

Внутри скобок можно указывать переменную.

```
const number1 = parseInt(value);

console.log(number1); // => 0
```

Или конкретное значение.

```
const number2 = parseInt('10');

console.log(number2); // => 10
```

Если преобразуется число с плавающей точкой, то отбрасывается вся дробная часть.

```
const number5 = parseInt(3.5);

console.log(number5); // => 3
```

С помощью **parseFloat()** точно так же можно преобразовать строку в число с плавающей точкой:

```
const value3 = parseFloat('0.5');

console.log(value3); // 0.5
```

## <a name="неизменяемость">Неизменяемость и примитивные типы</a>

Что произойдет, если попытаться изменить символ в строке?

```
let firstName = 'Alexander';
```

Код выполнится без ошибок.

```
firstName[0] = 'B';

console.log(firstName); // => Alexander
```

Как это ни странно, но значение переменной firstName останется прежним, хотя код выполнится без ошибок. Так происходит из-за неизменяемости примитивных типов в JavaScript — язык не дает никакой физической возможности поменять строку. Неизменяемость примитивных типов важна по многим причинам, ключевая — производительность. Но что делать, если нам действительно нужно ее изменить? Для этого и существуют переменные.

Есть большая разница между изменением значения переменной и изменением самого значения. Примитивные типы в JavaScript поменять нельзя, а заменить значение переменной — без проблем.

## <a name="типизация">Слабая типизация</a>

JavaScript — это язык со **слабой типизацией**. Он знает о существовании разных типов (числа, строки и др.), но относится к их использованию не очень строго, пытаясь преобразовывать информацию, когда это кажется разумным.

```
console.log(1 + '7'); // => 17
```

В языках со **строгой типизацией** сложить число со строкой не получится.

JavaScript был создан для интернета, а в интернете вся информация — это строки. Даже когда вы вводите на сайте номер телефона или год рождения, на сервер эта информация поступает не как числа, а как строки. Поэтому авторы языка решили, что автоматически преобразовывать типы — правильно и удобно.

## <a name="функции">Функции и их вызов</a>

Для выражения любой произвольной операции в программировании существует понятие функция. Функции бывают как встроенные, так и добавленные программистом.

**Функции** — одна из ключевых конструкций в программировании, без них невозможно сделать практически ничего.

Параметры (или _аргументы_) — это информация, которую функция получает при вызове. Именно на основе этой информации функция, как правило, вычисляет что-то и выдает результат.

Мы создали константу _result_ и указали интерпретатору записать в нее результат, возвращаемый функцией _length()_ при ее вызове. В этом смысле функции подобны операциям – они всегда возвращают результат своей работы.

```
const result = length('Hello!');
```

Запись _length('Hello!')_ означает, что вызывается функция с именем _length_, в которую был передан параметр _'Hello!'_. Функция _length()_ считает длину именно той строки, которая ей была передана.

Вызов функции всегда обозначается скобками **()**, идущими сразу за именем функции. В скобках может быть любое количество параметров, а иногда — вообще ни одного. Количество зависит от используемой функции.

```
const result = pow(2, 3); // 2 * 2 * 2
```

Вызов pow(2, 3) возвращает значение 2 в 3 степени.

По большому счету, операторы и функции — это одно и то же. Ключевая разница только в том, как они записываются. Если представить (гипотетически) сложение как функцию, то она будет выглядеть так:

* Обычное сложение: _3 + 5;_ // 8
* Сложение, представленное как функция: _+(3, 5);_

Функции вызываются и возвращают результат, который затем может быть использован в дальнейших вычислениях или, например, выведен на экран.

### <a name="Math">Математические функции</a>

В предыдущем задании мы использовали самописную функцию **pow()**, а теперь давайте рассмотрим ее версию, встроенную в сам язык.

```
Math.pow(2, 3); // 8
```

Что такое **Math**? Технически — это объект, доступный из любого места программы. Функции для математических операций вызываются через **Math.**.

Функция _Math.pow()_, возводящая число в какую-нибудь степень, принимает два параметра: **какое число возводить** и **в какую степень возводить**. Если вызывать _pow()_ без параметров, то вернется **NaN**. Функция честно пытается выполнить возведение в степень, но если значение не передано, то интерпретатор автоматически передает ей **undefined**.

Откуда мы знаем, сколько каких параметров нужно функции **Math.pow()** и какого типа будет «возврат»? Мы заглянули в **сигнатуру** этой функции. Сигнатура определяет входные параметры и их типы, а также выходной параметр и его тип.

### <a name="параметры">Параметры по умолчанию</a>

Рассмотрим функцию **round()**, которая округляет число с плавающей точкой:

```
const result = round(10.25, 0); // 10
```

Мы передали в нее два параметра: число, которое нужно округлить, и точность округления. **0** означает, что округление будет до ближайшего целого значения.

Чаще всего нужно округлять именно до целого числа (а не до десятых, например), поэтому создатели функции **round()** сделали второй параметр _необязательным_ и задали ему внутри функции значение по умолчанию **0**. Значит, можно не указывать второй параметр, а результат будет тем же:

```
const result = round(10.25); // 10
```

Если функция в JavaScript принимает необязательные параметры, то они всегда стоят после обязательных. Их количество может быть любым (это зависит от самой функции), но они всегда идут рядом и в конце списка аргументов.

### <a name="вызов">Вызов функции - выражения</a>

В программировании выражение – нечто, возвращающее результат, который можно использовать. Математические операции (сложение, вычитание), строковые операции (конкатенация) – все это выражения.

Особенность выражений в том, что они возвращают результат, который можно, например, присвоить константе или вывести на экран.

Но не все в программировании является выражением. Определение переменной – это инструкция, она не может быть частью выражения. То есть такой код выдаст ошибку:

```
10 + const sum = 1 + 5;
```

Выражения можно комбинировать, получая все более сложное поведение в самых неожиданных местах и самым неожиданным образом.

Функции возвращают результат, поэтому они считаются выражениями. Из этого автоматически следует много интересного. Например, мы можем использовать вызов функции прямо в математических операциях. Все это справедливо для любых функций, например, строковых.

### <a name="переменные-параметры">Функции с переменным числом параметров</a>

Интересная особенность некоторых функций — принимать переменное число параметров.

```
Math.max(1, 10, 3); // 10
```

Функция **Math.max()** находит максимальное значение среди переданных параметров.

```
Math.max([value1[, value2[, ...]]])
```

Такая запись говорит о том, что эта функция принимает на вход любое число параметров (и даже может быть вызвана без них). Необязательность передаваемых параметров описывается скобками **[ ]**, точно так же описываются и опциональные параметры, у которых есть значения по умолчанию. Возможность передачи любого числа параметров зашита в этой части **[, ...]**.

### <a name="детерминированность">Детерминированность</a>

Независимо от того, какой язык программирования используется, функции внутри него обладают некоторыми фундаментальными свойствами. Зная эти свойства, легче прогнозировать поведение функций, способы их тестирования и место их использования. К таким свойствам относится _детерминированность_.

Функция называется **детерминированной** тогда, когда для одних и тех же входных параметров она возвращает один и тот же результат.

Например, функция, считающая количество символов, детерминированная, в свою очередь функция, возвращающая случайное число, не является детерминированной, так как у одного и того же входа (даже если он пустой, то есть параметры не принимаются) мы получим всегда разный результат.

Детерминированность серьезно влияет на многие аспекты. Детерминированные функции удобны в работе, их легко оптимизировать, легко тестировать. Если есть возможность сделать функцию детерминированной, то лучше ее такой и сделать.

### <a name="побочные">Побочные эффекты</a>

Что возвращает функция _console.log()?_ Ответ: что бы она ни возвращала, это значение никак не используется.

**console.log()** выводит что-то на экран, но это не возврат значения, это просто какое-то действие, которое выполняет функция. Вывод на экран и возврат значения из функции — разные и независимые операции.

С точки зрения программы вывод на экран — это так называемый **побочный эффект**. Побочным эффектом называют действия, которые изменяют внешнее окружение (среду выполнения). К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран или печать на принтере и так далее.

Побочные эффекты — один из основных источников проблем и ошибок в программных системах. Код с побочными эффектами сложен в тестировании, ненадежен. При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы (записать в базу, вывести на экран, отправить по сети и так далее).

## <a name="библиотека">Стандартная библиотека</a>

JavaScript, как и любой другой язык, поставляется с набором полезных функций. Все вместе они составляют так называемую **стандартную библиотеку**. В нее обычно входят тысячи функций, которые невозможно выучить — этого и не нужно делать.

Любой разработчик в процессе своего профессионального взросления знакомится со все более интересными функциями, решающими его задачи более элегантно, и таким образом пополняет свой арсенал.

Вот некоторые советы, как узнавать о новых функциях:

* Всегда четко отслеживайте, с чем вы сейчас работаете (какой тип данных). Почти всегда вы найдете необходимую функцию в соответствующем разделе документации — например, для работы со строками нужно изучать строковые функции;
* Периодически открывайте раздел со стандартными функциями по изучаемой тематике и просто пробегайтесь по ним, изучая сигнатуры и способы использования;
* Чаще читайте чужой код, особенно код библиотек, которые вы используете. Он весь доступен на GitHub.

У JavaScript есть свои особенности по структуре стандартной библиотеки. Так как его код может исполняться в разных средах, таких как серверное окружение или браузер, то возможности стандартной библиотеки сильно зависят от варианта использования.

## <a name="свойства">Свойства и методы</a>

В JavaScript свойства встроены прямо в язык. Они указываются через точку сразу после переменной (или константы):

```
const name = 'Robb';
const len = name.length;
```

Свойства связаны с данными, у которых они берутся. Для стандартных типов все свойства описаны в документации, как например, у строк. При этом у чисел вообще нет свойств.

JavaScript позволяет обращаться к свойствам, которые не существуют (например, при опечатках). В таком случае их значением является undefined.

### <a name="методы">Методы</a>

В JavaScript у данных есть не только свойства, но и методы. **Методы** - это функции, которые находятся внутри свойств. Это означает, что метод можно вызвать как функцию, но при этом он работает как свойство и вызывается через точку.

```
const name = 'Robb';
const upperName = name.toUpperCase();
```

Встроенные методы всегда оперируют теми данными, с которыми они связаны. Методов у данных обычно значительно больше, чем свойств, например, для строк их несколько десятков.

Методы есть и у чисел, но технически всё несколько сложнее. Методы есть не у самих чисел, а у данных (объектов) типа **Number**. Числа, записанные в переменные или константы, автоматически преобразуются к данному типу во время обращения к ним, в это время происходит так называемый **boxing**.

### <a name="неизменность">Неизменяемость</a>

Логика справедлива для методов всех примитивных типов. Более того, попытка изменить значение свойства этих данных ни к чему не приведет:

```
const name = 'Tirion';
console.log(name.length); // => 6

name.length = 100;
console.log(name.length); // => 6
```

Вместо изменения значения можно заменить значение. Для этого понадобятся переменные:

```
let name = 'Tirion';
name = name.toUpperCase();

console.log(name); // => TIRION
```

### <a name="как-выражения">Свойства и методы как выражения</a>

Свойства и методы — такие же выражения, как переменные, константы или вызовы функции, а значит, их можно всячески комбинировать.

```
const name1 = 'Robb';
const name2 = 'Shaya';

console.log(Math.min(name1.length, name2.length)); // => 4
```

### <a name="цепочка">Цепочка вызовов</a>

Синтаксис нескольких подряд идущих операций можно записать как:

```
const name = 'Tirion';

console.log(name.length.toString());
```

Все, что произошло в этом коде — это объединение уже известных возможностей языка. Такое в программировании происходит довольно часто. Даже не зная синтаксиса, можно пробовать комбинировать различные подходы, и есть неплохая вероятность, что они заработают.

Самый простой способ понять, как работает этот код — разбить цепочку на отдельные операции:

```
const name = 'Tirion';
const len = name.length;

console.log(len.toString());
```

Эти примеры абсолютно эквивалентны. Мы можем выполнять операции последовательно с промежуточным созданием констант, а можем строить непрерывную цепочку из свойств и методов. **В цепочках вычисления всегда идут слева направо.**

## <a name="определение">Определение функций</a>

Определение собственных функций значительно упрощает написание и поддержку программ. Функции позволяют объединять сложные (составные) операции в одну.

// **Определение функции**

// Определение не вызывает и не выполняет функцию

// Мы лишь говорим, что теперь такая функция существует

```
 const showGreeting = () => {
  const text = 'Hello, Hexlet!';
  console.log(text);
};
``` 
// **Вызов функции**

```
 showGreeting(); // => Hello, Hexlet!
``` 
В отличие от обычных данных, функции _выполняют действия_, поэтому их имена практически всегда должны быть _глаголами_: «построить что-то», «нарисовать что-то», «открыть что-то».

Все, что описывается внутри фигурных скобок {}, называется **телом функции**. Внутри тела можно описывать любой код. Считайте, что это маленькая самостоятельная программа, набор произвольных инструкций. Тело выполняется ровно в тот момент, когда запускается функция. Причем каждый вызов функции запускает тело независимо от других вызовов. Кстати, тело может быть пустым.

Определение функции подозрительно похоже на создание константы. Действительно, в реальности, определение функции состоит из двух частей: собственно определения и присваивания константе:

* Определение: **() => { }**
* Присваивание **const nameOfFunction = ...**

### <a name="возврат">Возврат значений</a>

**return** – особая инструкция, которая берет выражение, записанное справа, и отдает его наружу, тому коду, который вызвал функцию. Как только JavaScript натыкается на return, выполнение функции на этом завершается.

Любой код после _return_ не выполняется:

```
const greetingWithCodeAfterReturn = () => {
  return 'Hello, Hexlet!';
  console.log('Я никогда не выполнюсь');
};
```
Возвращать можно не только конкретное значение. Так как _return_ работает с выражениями, то справа от него может появиться почти все что угодно. Здесь нужно руководствоваться принципами читаемости кода.

### <a name="параметры-функций">Параметры функций</a>

Функции могут не только возвращать значения, но и принимать их в виде параметров (их еще называют аргументами).

Представим, что перед нами стоит задача – реализовать функцию **getLastChar()**. Она возвращает последний символ в строке, переданной на вход как параметр.

Вот как будет выглядеть использование этой функции:

```
// Передача параметров напрямую без переменных
getLastChar('Hexlet'); // t

// Передача параметров через переменные
const name1 = 'Hexlet';
getLastChar(name1); // t

const name2 = 'Goo';
getLastChar(name2); // o
```

Из описания и примеров кода мы можем сделать следующие выводы:

* Нам нужно определить функцию **getLastChar()**
* Функция должна принимать на вход один параметр строкового типа
* Функция должна возвращать значение строкового типа

Имя параметра может быть любым. Главное, чтобы оно отражало смысл того значения, которое содержится внутри. Мы могли бы определить функцию и вот так:

```
const getLastChar = (str) => {
  return str[str.length - 1];
};
```

Точно таким же образом можно указывать два, три и более параметров. Каждый параметр отделяется от другого запятой:

```
// функция по нахождению среднего числа
const average = (a, b) => {
  return (a + b) / 2;
};

average(1, 5); // 3
average(1, 2); // 1.5
```

Тоже самое относится и к методам. Они могут требовать на вход любое количество параметров, которое им нужно для работы:

```
// первый параметр – что ищем
// второй параметр – на что меняем
'google'.replace('go', 'mo'); // moogle
```

Чтобы создать такие функции и методы, нужно в определении указать необходимое количество параметров через запятую, дав им понятные имена. Ниже пример определения функции _replace()_, которая заменяет в слове одну часть строки на другую:

```
const replace = (text, from, to) => {
  // здесь тело функции, но мы его опускаем, чтобы не отвлекаться
};

replace('google', 'go', 'mo'); // moogle
```

Когда параметров два и более, то практически для всех функций становится важен порядок передачи этих параметров. Если его поменять, то функция отработает по-другому.

### <a name="необязательные-параметры">Необязательные параметры функций</a>

В программировании большое количество функций и методов имеют параметры, которые редко меняются. В таких случаях этим параметрам задают значения по умолчанию, которые можно поменять по необходимости.

Значение по умолчанию выглядит как обычное присваивание в определении. Оно срабатывает только в том случае, если аргумент не передан. К этому нужно привыкнуть.

Значение по умолчанию может быть даже в том случае, когда параметр один:

```
const print = (text = 'nothing') => console.log(text);

print(); // nothing
print("World"); // World
```

Параметров со значениями по умолчанию может быть сколько угодно. У значений по умолчанию есть одна особенность — они должны идти в самом конце списка параметров. Значения, передаваемые функции при вызове, всегда записываются в параметры слева направо, в том порядке, в котором они переданы. Получается, что если значения по умолчанию идут слева в списке параметров, перед обычными параметрами, то при вызове функции с какими-либо аргументами на место значений по умолчанию встанут значения аргументов.

### <a name="упрощенный-синтаксис">Упрощенный синтаксис функций</a>

По сравнению с некоторыми (в первую очередь функциональными) языками, определение функции в JavaScript выглядит довольно громоздко:

```
const square = (x) => {
  return x ** 2;
};
```

Здесь используется много дополнительных символов и слово return. С версии es6 в языке появился альтернативный, сокращенный синтаксис, который, в некоторых ситуациях, значительно упрощает восприятие и сокращает количество кода.

```
const double = (x) => x ** 2;
```

Отличия от полного определения два: пропали фигурные скобки и инструкция return. Сокращенная запись функции делает возврат автоматически. Подразумевается, что внутри такой функции ровно одно выражение, которое вычисляется, и его результат сразу возвращается наружу.

Обратите внимание на **отсутствие** фигурных скобок. Разработчики, которые не привыкли использовать такой синтаксис, иногда пишут подобный код _const sum = (a, b) => { a + b };_, а потом долго не могут понять, почему он не работает. Ответ очень простой: если стоят фигурные скобки, то это не сокращенная форма, а значит, чтобы функция вернула значение, придется поставить return.

## <a name="логика">Логика</a>

Список операций сравнения в JavaScript:

* **<** меньше
* **<=** меньше или равно
* **>** больше
* **>=** больше или равно
* **===** равно
* **!==** не равно

### <a name="логический-тип">Логический тип</a>

Наряду со строками **(string)**, целыми и рациональными числами **(number)**, логический тип **(boolean)** — это один из примитивных типов данных в JavaScript.

```
const isInfant = (age) => age < 1;
```

Пользуемся тем фактом, что любая операция — это выражение, поэтому единственной строчкой функции пишем «вернуть то значение, которое получится в результате сравнения age < 1».

В зависимости от пришедшего аргумента, сравнение будет либо истинным (true), либо ложным (false), и return вернет этот результат.

### <a name="предикаты">Предикаты</a>

Предикаты во всех языках принято именовать особым образом для простоты анализа. В JavaScript предикаты, как правило, начинаются с префикса **is**, **has** или **can**, но не ограничены этими словами. Примеры:

* _isInfant()_ — «младенец ли?»
* _hasChildren()_ — «есть ли дети?»
* _isEmpty()_ — «пустой ли?»
* _hasErrors()_ — «есть ли ошибки?»

Функция может считаться предикатом только если она возвращает **boolean**.

### <a name="комбинирование">Комбинирование логических операций</a>

Логические операции — это выражения. Значит, логические операции можно комбинировать с другими выражениями.

Например, мы хотим проверить четность числа, то есть кратность двум. В программировании используют такой подход:

* проверяют остаток от деления на 2:
* если остаток 0, то число было четным
* если остаток не 0, то число было нечетным

**Остаток от деления** — простая, но очень важная концепция в арифметике, алгебре, и даже в теории чисел и криптографии. Идея проста: нужно разделить число на несколько равных групп, и если в конце что-то останется — это и есть остаток от деления.

Делим конфеты поровну между людьми:

* 7 конфет, 2 человека: 2 x 3 + остаток 1. Значит, 7 не кратно 2.
* 21 конфету, 3 человека: 3 x 7 + остаток 0. Значит, 21 кратно 3.
* 19 конфет, 5 человек: 5 x 3 + остаток 4. Значит, 19 не кратно 5.

Оператор **%** вычисляет остаток от деления (не путайте с делением):

```
7 % 2;  // 1
21 % 3; // 0
19 % 5; // 4
```

Напишем функцию проверки четности:

```
const isEven = (number) => number % 2 === 0;

isEven(10); // true
isEven(3);  // false
```

В одном выражении мы скомбинировали логический оператор **===** (проверка равенства) и арифметический оператор **%**.

Приоритет арифметических операций выше логических. Значит, сначала вычисляется арифметическое выражение **number % 2**, затем результат участвует в логическом сравнении.

Словами это можно расшифровать так: _«вычислить остаток от деления числа number на 2 и сравнить, равен ли остаток нулю; затем вернуть результат проверки равенства»_.

### <a name="операторы">Логические операторы</a>

Как вы знаете, некоторые сайты при регистрации хотят пароль от 8 до 20 символов в длину. Честно говоря, это странное ограничение, но что поделать. В математике мы бы написали 8 < x < 20 (где x это длина конкретного пароля), но в JavaScript такой трюк не пройдет. Нам придется сделать два отдельных логических выражения и соединить их специальным оператором «И»:

_Пароль длиннее 8 символов **И** пароль короче 20 символов._

**&&** - означает «И» (в математической логике это называют _конъюнкцией_). Все выражение считается истинным только в том случае, когда истинен каждый операнд — каждое из составных выражений. Иными словами, **&&** означает «и то, и другое».

Приоритет этого оператора ниже, чем приоритет операторов сравнения, поэтому выражение отрабатывает правильно без скобок.

Кроме **&&**, часто используется оператор **||** — «ИЛИ» (_дизъюнкция_). Он означает «или то, или другое, или оба». Операторы можно комбинировать в любом количестве и любой последовательности, но когда одновременно встречаются **&&** и **||**, то приоритет лучше задавать скобками.

**ИЛИ ||**

   A   |   B   |  A || B
-------|:-----:|:--------:
TRUE   | TRUE  |  TRUE
TRUE   | FALSE |  TRUE
FALSE  | TRUE  |  TRUE
FALSE  | FALSE |  FALSE

Область математики, в которой изучаются логические операторы, называется _булевой алгеброй_. Ниже (и выше) показаны _«таблицы истинности»_ — по ним можно определить, каким будет результат применения оператора:

**И &&**

   A   |   B   |  A && B
-------|:-----:|:--------:
TRUE   | TRUE  |  TRUE
TRUE   | FALSE |  FALSE
FALSE  | TRUE  |  FALSE
FALSE  | FALSE |  FALSE

Наряду с _конъюнкцией_ (И) и _дизъюнкцией_ (ИЛИ), часто используется операция **«отрицание»**. Отрицание меняет логическое значение на противоположное. В программировании ему соответствует унарный оператор **!**.

Отрицание — мощный инструмент, который позволяет лаконично выражать задуманные правила в коде без необходимости писать новые функции.

А что если написать так _!!isEven(10)_? Внезапно, но код сработает. В логике двойное отрицание подобно отсутствию отрицания вообще.

```
isEven(10);   // true
!isEven(10);  // false
!!isEven(10); // true
```

### <a name="результат-операций">Результат логических операций</a>

Что будет напечатано на экран?

```
console.log(0 || 1); // Правильный ответ: 1
```

Оператор **ИЛИ** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в _true_.

Ниже пример с оператором **И**:

```
console.log(0 && 1); // => 0
```

Оператор И работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в _false_.

В JavaScript есть два простых правила, по которым происходят преобразования:

1. **0, '' (пустая строка), undefined, NaN, null** приводятся к false. Эти значения называют _falsy_.
2. Все остальное приводится к _true_

Этим активно пользуются в разработке, например, для определения значения по умолчанию:

```
const value = name || '';

// Примеры
234 || ''; // 234
'hexlet' || ''; // hexlet
undefined || ''; // ''
```

Если _name_ примет одно из falsy-значений, константе _value_ будет присвоена пустая строка. В этом случае в последующем коде мы сможем работать с _value_ как со строкой.

Но здесь есть потенциальный баг. Если _name_ содержит falsy-значение, а присваивание константе _value_ значений типа 0, undefined, NaN или null допустимо, то код выше начнет работать неверно:

```
// Упс
false || ''; // ''
0 || ''; // ''
undefined || ''; // ''
```

Мы рассмотрели операторы сравнения === и !== и упомянули, что в JavaScript так же есть операторы == и !=, но их не стоит использовать. Отличия как раз заключаются в преобразовании типов:

```
console.log('' === false); // => false
console.log('' == false);  // => true
```

Пустая строка и false — это разные значения, поэтому оператор **===** говорит «ложь! они не равны!». Но оператор **==** преобразует типы, и с его точки зрения пустая строка и false равны. Это преобразование неявное, поэтому по возможности избегайте операторов **==** и **!=**.

### <a name="ошибка-выбора">Ошибка выбора</a>

Представьте себе задачу, в которой нам нужно проверить, что значение равно либо одному, либо другому. Например, переменная _value_ должна содержать одно из двух значений: _first_ или _second_. Начинающие разработчики иногда записывают это выражение так:

```
value === ('first' || 'second') // Не верно!
```

Правильная проверка:

```
value === 'first' || value === 'second' // Верно!
```


## <a name="условные-конструкции">Условные конструкции</a>

Условные конструкции позволяют изменить поведение программы в зависимости от проверяемых условий. Благодаря им у нас появляется возможность писать сложные программы, ведущие себя по-разному в зависимости от ситуации.

### <a name="if">if</a>

**if** — конструкция языка, управляющая порядком выполнения инструкций. В скобках ей передается выражение-предикат, а затем описывается блок кода в фигурных скобках. Этот блок кода будет выполнен, только если предикат — истина.

Если предикат — ложь, то блок кода в фигурных скобках пропускается, и функция продолжает свое выполнение дальше.

### <a name="else">else</a>
Добавим ключевое слово **else** и новый блок с фигурными скобками. Этот блок выполнится, только если условие в _if_ — ложь.

Существует два способа оформления конструкции **if-else**. С помощью отрицания можно изменить порядок блоков. 

Какой способ предпочтительнее? Человеческому мозгу проще мыслить прямолинейно, а не через отрицание. Старайтесь выбирать проверку, которая не содержит отрицаний, и подстраивайте содержимое блоков под нее.

### <a name="else-if">else if</a>

```
const getTypeOfSentence = (sentence) => {
  const lastChar = sentence[sentence.length - 1];
  let sentenceType;

  if (lastChar === '?') {
    sentenceType = 'question';
  } else if (lastChar === '!') {
    sentenceType = 'exclamation';
  } else {
    sentenceType = 'normal';
  }

  return `Sentence is ${sentenceType}`;
};

getTypeOfSentence('Who?'); // Sentence is question
getTypeOfSentence('No');   // Sentence is normal
getTypeOfSentence('No!');  // Sentence is exclamation
```

Теперь все условия выстроены в единую конструкцию. **else if** — это «если не выполнено предыдущее условие, но выполнено текущее». Получается такая схема:

* если последний символ это **?**, то _'question'_
* иначе, если последний символ это **!**, то _'exclamation'_
* иначе _'normal'_

Выполнится только один из блоков кода, относящихся ко всей конструкции _if_.